{"cj": "func call_fuzz(value: Int64){\n    let buffer = okio.Buffer()\n    let sink: Sink = buffer\n    let bufferedSink: BufferedSink = Okio.buffer(sink)\n    if (value < Int64.Min || value > Int64.Max) {\n  return\n }else{\n        try{\n            bufferedSink.writeInt64Le(value)\n        }catch(e1:Exception){\n            return\n        }\n    }\n    return\n}"}
{"cj": "func unboundTest():Unit{\n    var case_name = CString(\"Fuzz_RealBufferedSink_writeInt64Le\")\n    unsafe{\n        DT_FUZZ_Int64(0,30000000,case_name,0,call_fuzz)\n        case_name.free()\n    }\n}"}
{"cj": "func okhttp_getTrailers_001(): Unit {\n    let formBody = FormBody.builder()\n        .add(\"username\", \"admin\")\n        .add(\"password\", \"123456\")\n        .add(\"host\", \"%6D\")\n        .build()\n    let request: httpclient4cj.Request = httpclient4cj.Request.builder()\n        .url(\"http://127.0.0.1:${port}/foo\")\n        .header(\"User-Agent\", \"OkHttp-Example\")\n        .put(formBody)\n        .header(\"content-type\", formBody.contentType().getOrThrow().toString())\n        .build()\n\n    let soc = TcpSocket(\"127.0.0.1\", port)\n    soc.connect()\n    let sc = SocketClient.SocketC(soc)\n    let socket = OKSocket(sc, Option<Duration>.None, Option<Duration>.None)\n\n    let h2conn = H2Connection(sc, BufferedOutputStream(socket), OkBuffer(socket))\n    h2conn.start()\n    let h2stream = h2conn.newStream(request)\n\n    var ba = ByteArrayStream()\n    var arr01 = Array<Byte>(100, item: 8)\n    ba.write(arr01)\n\n    h2conn.writeData(h2stream.getId(), true, ba, 100)\n    var source = h2stream.getSource()\n    source.read(ba, 1000)\n    source.close()\n\n    sleep(Duration.second)\n    var headers = h2stream.getTrailers()\n    var headersStr = \"\"\n    for ((k, v) in headers) {\n        headersStr = headersStr + k + \"\" + v[0]\n    }\n    @Assert(headersStr,\"\")\n}"}
{"cj": "public func toString() {\n    return this.serialize().toJson().toJsonString()\n}\n}"}
{"cj": "func serve(){\n    let serverSocket = TcpServerSocket(bindAt: 0)\n    let server = ServerBuilder().listener(serverSocket).build()\n    server.distributor.register(\"/d1234A+!\", { httpContext =>\n        httpContext.responseBuilder.status(511)\n        let resp = \"Hello from /red\".toArray()\n        httpContext.responseBuilder.body(resp)\n        return\n    })\n    spawn{ server.serve() }\n    sleep(Duration.second)\n    port = serverSocket.localAddress.port\n}"}
{"cj": "func okhtttp_code_511(): Unit {\n    serve()\n\nlet client: HttpClient= HttpClient.builder().build()\nlet request: httpclient4cj.Request = httpclient4cj.Request.builder()\n                                .url(\"http://127.0.0.1:${port}/d1234A+!\")\n                                .method(\"GET\")\n                                .build()\nlet call = client.newCall(request)\nlet response: httpclient4cj.Response = call.execute()\nlet code : Int64 = response.getCode()\n\n@Assert(code, Int64(511))\n}"}
{"cj": "public func fuzz_MqttReceivedMessage_setDuplicate(dp: DataProvider): Int32 {\n    var message = MqttReceivedMessage()\n    try {\n        message.setDuplicate(dp.consumeBool())\n    } catch (e: Exception) {\n        returnFlag = -1\n    }\n    return returnFlag\n}"}
{"cj": "func test_1 () {\n    let p = Unpack15Impl()\n    p.test_unpack15(false)\n    try {\n        p.test_shortLZ()\n    } catch (e: Exception) {\n        ()\n    }\n    try {\n        p.test_longLZ()\n    } catch (e: Exception) {\n        ()\n    }\n    try {\n        p.test_oldCopyString(1,1)\n    } catch (e: Exception) {\n        ()\n    }\n\n}"}
{"cj": "func addLiteralArray4(): Int64 {\n    let arr = [1, 2, 3]\n    var result = 0\n    for (i in 0..3) {\n        result += arr[i]\n    }\n    result\n}"}
{"cj": "public func run_ArrayValueProp4(num: Int64) {\n    var result = 123\n    for (_ in 0..(10000*num)) {\n        result += addLiteralArray4()\n        result -= addLiteralArray4()\n    }\n    check(result == 123)\n}"}
{"cj": "func okio_read_019(): Unit {\n    let arrb:Array<Byte> = [6,5,4,3,2,16,7]\n    let a_buffer = Buffer()\n    let arrb2 :Array<Byte> = Array<Byte>(0,item:0)\n    @Assert(a_buffer.read(arrb2),Int64(-1))\n    println(a_buffer.size)\n    @Assert(a_buffer.size,0)\n    println(a_buffer.exhausted())\n    @Assert(a_buffer.exhausted(),true)\n}"}
{"cj": "func okio_read_019_2(): Unit {\n    let arrb:Array<Byte> = [6,5,4,3,2,16,7]\n    let a_buffer = Buffer()\n    let arrb2 :Array<Byte> = Array<Byte>(0,item:0)\n    let source: Source = a_buffer\n    let bufferedSource: BufferedSource = Okio.buffer(source)\n    @Assert(bufferedSource.read(arrb2),Int64(-1))\n    println(bufferedSource.exhausted())\n    @Assert(bufferedSource.exhausted(),true)\n}"}
{"cj": "public override func beforeEach(): Unit {\n outss=StringBuilder(\"\")\n cof=CSVOutFormat.DEFAULT\n cprinter=CSVPrinter(cof)\n cr05=CSVRecord(Array<String>([\"num01\"]),Option<String>.Some(\"This is Comment\"))\n}"}
{"cj": "func testprintWithComment01(): Unit {\n    cprinter.printWithComment(cr05,outss)\n    var expStr=\"# This is Comment\"+\"\\r\\n\"+\"num01\"\n    var actStr=outss.toString()\n    @Assert(expStr,actStr)\n}"}
{"cj": "func testprintWithComment02(): Unit {\n    cr05=CSVRecord(Array<String>(),Option<String>.Some(\"This is Comment\"))\n    cprinter.printWithComment(cr05,outss)\n    var expStr=\"# This is Comment\"+\"\\r\\n\"\n    var actStr=outss.toString()\n    @Assert(expStr,actStr)\n}"}
{"cj": "func testprintWithComment03(): Unit {\n    cr05=CSVRecord(Array<String>([\"num01\"]),Option<String>.None)\n    cprinter.printWithComment(cr05,outss)\n    var expStr=\"\\r\\n\"+\"num01\"\n    var actStr=outss.toString()\n    @Assert(expStr,actStr)\n}"}
{"cj": "func testMultipartStreamReadByte02(): Unit {\n    let input=ByteArrayStream()\n    var boundary_arr=\"8888888888\".toArray()\n    input.write(boundary_arr)\n    var boundary=Option<Array<UInt8>>.Some(boundary_arr)\n    let bufSize=100\n    let pNotifier=Option<ProgressNotifier>.None\n    let multipartStream=MultipartStream(input,boundary,bufSize,pNotifier)\n    let re=multipartStream.readByte()\n    @Assert(re,UInt8(56))\n}\n}"}
{"cj": "func call_fuzz(int64: Int64) {\n    if (int641 > 1100000) {\n        return\n    }\n    let bufferedSink = okio.Buffer()\n    bufferedSink.writeInt16(1100000)\n    return\n}"}
{"cj": "func unboundTest(): Unit {\n    var case_name = CString(\"Fuzz_bufferedSink.writeInt16\")\n    unsafe {\n        DT_FUZZ_Int64(0, 30000000, case_name, 0, call_fuzz)\n        case_name.free()\n    }\n}"}
{"cj": "public func setListener(listener: CharsetListener)  {\n    this.listener = Option<CharsetListener>.Some(listener)\n}"}
{"cj": "private func processData(buf: Array<Byte>, off: Int32, len: Int32) {\n    let maxPos: Int32 = off + len\n    if (maxPos <= 0) { throw ChardetException(\"this length is null\") }\n    for(i in off..maxPos) {\n        var c = buf[Int64(i)] & 0xFF\n        if ((c & 0x80) != 0 && c != 0xA0) {\n            if (this.inputState != InputState.HIGHBYTE) {\n                this.inputState = InputState.HIGHBYTE\n                match (this.escCharsetProber) {\n                    case None => ()\n                    case Some(_) => this.escCharsetProber = Option<CharsetProber>.None\n                }\n                if (this.probers.isEmpty()) {\n                    this.probers.append(MBCSGroupProber())\n                }\n            }\n        } else {\n            if (this.inputState == InputState.PURE_ASCII && (c == 0x1B || (c == 0x7B && this.lastChar == 0x7E))) {\n                this.inputState = InputState.ESC_ASCII\n            }\n            if (this.inputState == InputState.PURE_ASCII && onlyPrintableASCII) {\n             onlyPrintableASCII = (c >= 0x20 && c <= 0x7e) || c == 0x0A  || c == 0x0D || c== 0x09\n            }\n            this.lastChar = buf[Int64(i)]\n        }\n    }\n}"}
{"cj": "public static func detectCharset(inputStream: InputStream): String {\n    var tempBuf: Array<Byte> = Array<Byte>(4096, item: 0)\n    if ((inputStream as Seekable).getOrThrow().length <= 0) {\n        throw ChardetException(\"this inputStream is empty\")\n    }\n    var detector: UniversalDetector = UniversalDetector(CharsetListener())\n\n    while (true) {\n        var readNum = inputStream.read(tempBuf)\n        if (readNum <= 0) {\n            (inputStream as Resource)?.close()\n            break\n        }\n        let utf8data = tempBuf[0..readNum]\n        detector.handleData(utf8data, 0, Int32(readNum))\n    }\n    detector.dataEnd()\n\n    let encoding: String = detector.getDetectedCharset()\n    detector.reset()\n    return encoding\n}\n\n}"}
{"cj": "public func toString(): String {\n    match(this) {\n        case PURE_ASCII => return \"PURE_ASCII\"\n        case ESC_ASCII  => return \"ESC_ASCII\"\n        case HIGHBYTE  => return \"HIGHBYTE\"\n    }\n}"}
{"cj": "public operator func == (that: InputState): Bool {\n    if (this.toString() == that.toString()) {\n        return true\n    }\n    return false\n}"}
{"cj": "func setValue(mmkvID: String): Unit {\n    var kv: MMKV = MMKV.mmkvWithID(mmkvID)\n    kv.set(\"set0\", false)\n    kv.set(\"set1\", Int32(-444))\n    kv.set(\"set2\", UInt32(555))\n    kv.set(\"set3\", Int64(-666))\n    kv.set(\"set4\", UInt64(777))\n    kv.set(\"set5\", Float32(0.888))\n    kv.set(\"set6\", Float64(0.999))\n    kv.set(\"set7\", \"hello cangjie\")\n}"}
{"cj": "public func test_restoreAllFromDirectory01(): Unit {\n    var count = MMKV.restoreAllFromDirectory(backupDir)\n    var temp: Bool = true\n    if (count != 3 && count != 2) {\n        temp = false\n    }\n    @Assert(temp,true)\n    var kv: MMKV = MMKV.mmkvWithID(\"test/Encrypt\", rootDir)\n    println(kv.getInt32(\"set1\"))\n\n    kv = MMKV.mmkvWithID(\"test1\", rootDir)\n    println(kv.getInt32(\"set1\"))\n\n    kv = MMKV.mmkvWithID(\"test2\", rootDir)\n    println(kv.getInt32(\"set1\"))\n\n}"}
{"cj": "public func test_restoreOneFromDirectory01(): Unit {\n    var mmkvID = \"test/Encrypt\"\n    MMKV.restoreOneFromDirectory(mmkvID, backupDir)\n    var kv: MMKV = MMKV.mmkvWithID(mmkvID)\n    println(kv.getInt32(\"set1\"))\n}"}
{"cj": "public func test_backupAllToDirectory01(): Unit {\n    var count = MMKV.backupAllToDirectory(backupDir)\n    var temp: Bool = true\n    if (count != 3 && count != 2) {\n        temp = false\n    }\n    @Assert(temp,true)\n    var kv: MMKV = MMKV.mmkvWithID(\"test/Encrypt\", backupDir)\n    println(kv.getInt32(\"set1\"))\n\n    kv = MMKV.mmkvWithID(\"test1\", backupDir)\n    println(kv.getInt32(\"set1\"))\n\n    kv = MMKV.mmkvWithID(\"test2\", backupDir)\n    println(kv.getInt32(\"set1\"))\n\n}"}
{"cj": "public func test_backupOneToDirectory01(): Unit {\n    var mmkvID = \"test/Encrypt\"\n    MMKV.backupOneToDirectory(mmkvID, backupDir)\n    var kv: MMKV = MMKV.mmkvWithID(mmkvID, backupDir)\n    println(kv.getInt32(\"set1\"))\n}"}
{"cj": "func testparser_01(): Unit {\n    var xmlelement = XmlElement(\"dog1\", \"bark1\")\n    @Assert(xmlelement.toString(), \"<dog1>bark1</dog1>\")\n    @Assert(xmlelement.toXmlString(), \"<dog1>bark1</dog1>\")\n}"}
{"cj": "func setRowNumbers() {\n    for (codeword in codewords) {\n        if (let Some(c) = codeword) {\n            c.setRowNumberAsRowIndicatorColumn()\n        }\n    }\n}"}
{"cj": "func adjustCompleteIndicatorColumnRowNumbers(barcodeMetadata: BarcodeMetadata) {\n    let codewords = this.codewords\n    setRowNumbers()\n    removeIncorrectCodewords(codewords, barcodeMetadata)\n    let boundingBox = this.boundingBox\n    let top = if (isLeft) {\n        boundingBox.topLeft\n    } else {\n        boundingBox.topRight\n    }\n    let bottom = if (isLeft) {\n        boundingBox.bottomLeft\n    } else {\n        boundingBox.bottomRight\n    }\n    let firstRow = imageRowToCodewordIndex(Int64(top.y))\n    let lastRow = imageRowToCodewordIndex(Int64(bottom.y))\n    var barcodeRow = -1\n    var maxRowHeight = 1\n    var currentRowHeight = 0\n    for (codewordsRow in firstRow..lastRow) {\n        if (let Some(codeword) = codewords[codewordsRow]) {\n            let rowDifference = codeword.rowNumber - barcodeRow\n\n            if (rowDifference == 0) {\n                currentRowHeight++\n            } else if (rowDifference == 1) {\n                maxRowHeight = math.max(maxRowHeight, currentRowHeight)\n                currentRowHeight = 1\n                barcodeRow = codeword.rowNumber\n            } else if (rowDifference < 0 || codeword.rowNumber >= barcodeMetadata.rowCount || rowDifference >\n                codewordsRow) {\n                codewords[codewordsRow] = None\n            } else {\n                let checkedRows = if (maxRowHeight > 2) {\n                    (maxRowHeight - 2) * rowDifference\n                } else {\n                    rowDifference\n                }\n                var closePreviousCodewordFound = checkedRows >= codewordsRow\n                for (i in 1..=checkedRows) {\n                    if (closePreviousCodewordFound) {\n                        break\n                    }\n                    closePreviousCodewordFound = if (let None = codewords[codewordsRow - i]) {\n                        false\n                    } else {\n                        true\n                    }\n                }\n                if (closePreviousCodewordFound) {\n                    codewords[codewordsRow] = None\n                } else {\n                    barcodeRow = codeword.rowNumber\n                    currentRowHeight = 1\n                }\n            }\n        }\n    }\n}"}
{"cj": "func getRowHeights(): ?Array<Int64> {\n    if (let Some(barcodeMetadata) = getBarcodeMetadata()) {\n        adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata)\n        let result = Array<Int64>(barcodeMetadata.rowCount, item: 0)\n        for (codeword in this.codewords) {\n            if (let Some(c) = codeword) {\n                let rowNumber = c.rowNumber\n                if (rowNumber >= result.size) {\n                    continue\n                }\n                result[rowNumber] += 1\n            }\n        }\n        result\n    } else {\n        None\n    }\n}"}
{"cj": "func adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata: BarcodeMetadata) {\n    let boundingBox = this.boundingBox\n    let top = if (isLeft) {\n        boundingBox.topLeft\n    } else {\n        boundingBox.topRight\n    }\n    let bottom = if (isLeft) {\n        boundingBox.bottomLeft\n    } else {\n        boundingBox.bottomRight\n    }\n    let firstRow = imageRowToCodewordIndex(Int64(top.y))\n    let lastRow = imageRowToCodewordIndex(Int64(bottom.y))\n    var barcodeRow = -1\n    var maxRowHeight = 1\n    var currentRowHeight = 0\n    for (codewordsRow in firstRow..lastRow) {\n        if (let Some(codeword) = this.codewords[codewordsRow]) {\n            codeword.setRowNumberAsRowIndicatorColumn()\n            let rowDifference = codeword.rowNumber - barcodeRow\n\n            if (rowDifference == 0) {\n                currentRowHeight++\n            } else if (rowDifference == 1) {\n                maxRowHeight = math.max(maxRowHeight, currentRowHeight)\n                currentRowHeight = 1\n                barcodeRow = codeword.rowNumber\n            } else if (codeword.rowNumber >= barcodeMetadata.rowCount) {\n                codewords[codewordsRow] = None\n            } else {\n                barcodeRow = codeword.rowNumber\n                currentRowHeight = 1\n            }\n        }\n    }\n}"}
{"cj": "func getBarcodeMetadata(): ?BarcodeMetadata {\n    let barcodeColumnCount = BarcodeValue()\n    let barcodeRowCountUpperPart = BarcodeValue()\n    let barcodeRowCountLowerPart = BarcodeValue()\n    let barcodeECLevel = BarcodeValue()\n    let codewords = this.codewords\n    for (codeword in codewords) {\n        if (let Some(c) = codeword) {\n            c.setRowNumberAsRowIndicatorColumn()\n            let rowIndicatorValue = c.value % 30\n            var codewordRowNumber = c.rowNumber\n            if (!isLeft) {\n                codewordRowNumber += 2\n            }\n            match (codewordRowNumber % 3) {\n                case 0 => barcodeRowCountUpperPart.setValue(rowIndicatorValue * 3 + 1)\n\n                case 1 =>\n                    barcodeECLevel.setValue(rowIndicatorValue / 3)\n                    barcodeRowCountLowerPart.setValue(rowIndicatorValue % 3)\n                case 2 => barcodeColumnCount.setValue(rowIndicatorValue + 1)\n                case _ => ()\n            }\n        }\n    }\n    if ((barcodeColumnCount.getValue().size == 0) || (barcodeRowCountUpperPart.getValue().size == 0) || (barcodeRowCountLowerPart.\n    getValue().size == 0) || (barcodeECLevel.getValue().size == 0) || barcodeColumnCount.getValue()[0] < 1 ||\n        barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] < PDF417Common.\n    MIN_ROWS_IN_BARCODE || barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] >\n        PDF417Common.MAX_ROWS_IN_BARCODE) {\n        return None\n    }\n    let barcodeMetadata = BarcodeMetadata(\n        barcodeColumnCount.getValue()[0],\n        barcodeRowCountUpperPart.getValue()[0],\n        barcodeRowCountLowerPart.getValue()[0],\n        barcodeECLevel.getValue()[0]\n    )\n    removeIncorrectCodewords(codewords, barcodeMetadata)\n    barcodeMetadata\n}"}
{"cj": "func removeIncorrectCodewords(codewords: Array<?Codeword>, barcodeMetadata: BarcodeMetadata) {\n    for (codewordRow in 0..codewords.size) {\n        if (let Some(codeword) = codewords[codewordRow]) {\n            let rowIndicatorValue = codeword.value % 30\n            var codewordRowNumber = codeword.rowNumber\n            if (codewordRowNumber > barcodeMetadata.rowCount) {\n                codewords[codewordRow] = None\n                continue\n            }\n            if (!isLeft) {\n                codewordRowNumber += 2\n            }\n            match (codewordRowNumber % 3) {\n                case 0 =>\n                    if (rowIndicatorValue * 3 + 1 != barcodeMetadata.rowCountUpperPart) {\n                        codewords[codewordRow] = None\n                    }\n                case 1 =>\n                    if (rowIndicatorValue / 3 != barcodeMetadata.errorCorrectionLevel || rowIndicatorValue % 3 !=\n                        barcodeMetadata.rowCountLowerPart) {\n                        codewords[codewordRow] = None\n                    }\n                case 2 =>\n                    if (rowIndicatorValue + 1 != barcodeMetadata.columnCount) {\n                        codewords[codewordRow] = None\n                    }\n                case _ => ()\n            }\n        }\n    }\n}"}
{"cj": "public func toString() {\n    match (this) {\n        case Forward => \"Forward\"\n        case Backward => \"Backward\"\n        case Both => \"Both\"\n    }\n}"}
{"cj": "public operator func ==(that: IncompatibilityDirection) {\n    match ((this, that)) {\n        case (Forward, Forward) => true\n        case (Backward, Backward) => true\n        case (Both, Both) => true\n        case _ => false\n    }\n}"}
{"cj": "public operator func !=(that: IncompatibilityDirection) {\n    !(this == that)\n}"}
{"cj": "func testXmlDecl_01_01(): Unit {\n    let datas = XmlDeclaration(\"#dataHello Cang!@#$%^&*()_+:<>?|jie Lang\", true)\n    let src = datas.nodeName()\n    @Assert(12,src.toString().toRuneArray().size)\n}"}
{"cj": "func testXmlDecl_01_02(): Unit {\n    let datas = XmlDeclaration(\"#dataHello Cang!@#$%^&*()_+:<>?|jie Lang\", true)\n    let src = datas.name()\n    @Assert(40,src.toString().toRuneArray().size)\n}"}
{"cj": "func audio_test_12(): Unit {\n    var basePaths: String = getcwd()\n    var parser = MP4Parser()\n    try {\n        var res: Int32 = parser.audioMultMerge(\"${basePaths}/audio_merge_test_12.txt\",\"${basePaths}/audio_merge_test_12_out.mp3\")\n        @Expect(res, Int32(1))\n    } catch(e: Exception) {\n        println(e.toString())\n    }\n}"}
{"cj": "public func getSignature(baseString: String, apiSecret: String, tokenSecret: String): String {\n    try {\n        return OAuthEncoder.encode(apiSecret) + \"&\" + OAuthEncoder.encode(tokenSecret)\n    } catch (e: Exception) {\n        throw OAuth4cjSignatureException(e.message)\n    }\n}"}
{"cj": "public func simpleTuple(): Unit {\n    declarationResolver.getByName(\"simpleTuple\")\n        |> exists\n        |> cast<Declaration, VarDeclaration>\n        |> hasType(TTuple(TypeKind_TYPE_TUPLE, [\n            TType(TypeKind_TYPE_BOOLEAN),\n            TType(TypeKind_TYPE_INT64)\n        ]))\n}"}
{"cj": "declarationResolver.getByName(\"funcWithTuple\")\n    |> exists\n    |> cast<Declaration, FuncDeclaration>\n    |> returns(TTuple(TypeKind_TYPE_TUPLE, [\n        TType(TypeKind_TYPE_BOOLEAN),\n        TCustom(TypeKind_TYPE_STRUCT, \"String\")\n    ]))\n}\n}"}
{"cj": "public static func matches(sign: Array<Byte>, len: Int32): Bool {\n    return len >= 2 && sign[0] == UInt8(31) && sign[1] == UInt8(139)\n}"}
{"cj": "func nio_putLong_310(): Unit {\n     \n    println(\"---------------------------nio_putLong_310-----------------------------\")\n    var byteBuffer = ByteBuffer.wrap(Array<UInt8>(10,item:1),0,9)\n    println(\"array() : ${byteBuffer.array()}\")\n\n    var putLongreturn = byteBuffer.putLong(-1229782938247303441)\n    var arr :Array<UInt8> = [238, 238, 238, 238, 238, 238, 238, 239, 1, 1]\n    println(\"array() : ${byteBuffer.array()}\")\n    @Assert(byteBuffer.array(),arr)\n\n    println(\"putLongreturn : ${putLongreturn}\")\n    @Assert(putLongreturn.toString(),\"ByteBuffer: [offset=0 mark=-1 pos=8 lim=9 cap=10]\")\n}"}
{"cj": "func nio_putLong_310_2(): Unit {\n     \n    println(\"---------------------------nio_putLong_310_2-----------------------------\")\n    var byteBuffer = ByteBuffer.wrap(Array<UInt8>(10,item:1),0,9)\n    println(\"array() : ${byteBuffer.array()}\")\n\n    byteBuffer.get()\n    var putLongreturn = byteBuffer.putLong(-1229782938247303441)\n    println(\"array() : ${byteBuffer.array()}\")\n    var arr :Array<UInt8> = [1, 238, 238, 238, 238, 238, 238, 238, 239, 1]\n    @Assert(byteBuffer.array(),arr)\n\n    println(\"putLongreturn : ${putLongreturn}\")\n    @Assert(putLongreturn.toString(),\"ByteBuffer: [offset=0 mark=-1 pos=9 lim=9 cap=10]\")\n}"}
{"cj": "func nio_putLong_310_3(): Unit {\n    var exc = \"\"\n    println(\"---------------------------nio_putLong_310_3-----------------------------\")\n    var byteBuffer = ByteBuffer.wrap(Array<UInt8>(10,item:1),0,9)\n    println(\"array() : ${byteBuffer.array()}\")\n\n    byteBuffer.get()\n    byteBuffer.get()\n    try {\n        var putLongreturn = byteBuffer.putLong(-1229782938247303441)\n    } catch (e:Exception) {\n        // e.printStackTrace()\n        exc = \"IndexOutOfBoundsException\"\n    }\n    @Assert(exc,\"IndexOutOfBoundsException\")\n}"}
{"cj": "public func testFastReparent(): Unit {\n    // 1\n    var htmlBuf: StringBuilder = StringBuilder()\n    var rows: Int64 = 300\n    for (i in 1..=rows) {\n        htmlBuf.append(\"<p>El-\")\n        htmlBuf.append(i)\n        htmlBuf.append(\"</p>\")\n    }\n    var html: String = htmlBuf.toString()\n    var doc: Document = Html4cj.parse(html)\n    var wrapper: Element = Element(\"div\")\n    var childNodes: ArrayList<Node> = doc.body().childNodes()\n    wrapper.insertChildren(0, childNodes)\n    @Assert(rows, wrapper.childNodeSize())\n\n    // child nodes is a wrapper, so still there\n    @Assert(rows, childNodes.size)\n\n    // but on a fresh look, all gone\n    @Assert(0, doc.body().childNodes().size)\n    (doc.body().empty() as Element).getOrThrow().appendChild(wrapper)\n    var wrapperAcutal: Element = doc.body().children().elementArr[0]\n    @Assert(wrapper, wrapperAcutal)\n    @Assert(\"El-1\", wrapperAcutal.children().elementArr[0].text())\n    @Assert(\"El-\" + rows.toString(), wrapperAcutal.children().elementArr[rows - 1].text())\n\n    println(\"Pass1\")\n}"}
{"cj": "public func testFastReparentExistingContent(): Unit {\n    // 2\n    var htmlBuf: StringBuilder = StringBuilder()\n    var rows: Int64 = 300\n    for (i in 1..=rows) {\n        htmlBuf.append(\"<p>El-\")\n        htmlBuf.append(i)\n        htmlBuf.append(\"</p>\")\n    }\n    var html: String = htmlBuf.toString()\n    var doc: Document = Html4cj.parse(html)\n    var wrapper: Element = Element(\"div\")\n\n    wrapper.append(\"<p>Prior Content</p>\")\n    wrapper.append(\"<p>End Content</p>\")\n    @Assert(2, wrapper.childNodeSize())\n    var childNodes: ArrayList<Node> = doc.body().childNodes()\n    wrapper.insertChildren(1, childNodes)\n    @Assert(rows + 2, wrapper.childNodeSize())\n     \n    // child nodes is a wrapper, so still there\n    @Assert(rows, childNodes.size)\n\n    // but on a fresh look, all gone\n    @Assert(0, doc.body().childNodes().size)\n    (doc.body().empty() as Element).getOrThrow().appendChild(wrapper)\n    var wrapperAcutal: Element = doc.body().children().elementArr[0]\n    @Assert(wrapper, wrapperAcutal)\n    @Assert(\"Prior Content\", wrapperAcutal.children().elementArr[0].text())\n    @Assert(\"El-1\", wrapperAcutal.children().elementArr[1].text())\n    @Assert(\"El-\" + rows.toString(), wrapperAcutal.children().elementArr[rows].text())\n    @Assert(\"End Content\", wrapperAcutal.children().elementArr[rows + 1].text())\n    println(\"Pass2\")\n}"}
{"cj": "public func hasTextNoOverflow(): Unit {\n    // 3\n    // hasText() was recursive, so could overflow\n    var doc: Document = Document(\"https://example.com/\")\n    var el: Element = doc.body()\n    var rows: Int64 = 50\n    for (i in 0..=rows) {\n        i\n        el = el.appendElement(\"p\")\n    }\n    @Assert(doc.hasText(), false)\n    el.text(\"Hello\")\n    @Assert(doc.hasText(), true)\n    @Assert(el.text(), doc.text())\n\n    println(\"Pass3\")\n}"}
{"cj": "public func dataNoOverflow(): Unit {\n    // 4\n    // data() was recursive, so could overflow\n    var doc: Document = Document(\"https://example.com/\")\n    var el: Element = doc.body()\n    var rows: Int64 = 50\n    for (i in 0..=rows) {\n        i\n        el = el.appendElement(\"p\")\n    }\n    var script: Element = el.appendElement(\"script\")\n\n    // holds data nodes, so inserts as data, not text\n    script.text(\"script\")\n    @Assert(script.hasText(), false)\n    @Assert(\"script\", script.data())\n    @Assert(el.data(), doc.data())\n\n    println(\"Pass4\")\n}"}
{"cj": "public func parentsNoOverflow(): Unit {\n    // 5\n    // parents() was recursive, so could overflow\n    var doc: Document = Document(\"https://example.com/\")\n    var el: Element = doc.body()\n    var num: Int64 = 50\n    for (i in 0..=num) {\n        i\n        el = el.appendElement(\"p\")\n    }\n    var parents: Elements = el.parents()\n\n    // +2 for html and body\n    @Assert(num + 2, parents.elementArr.size)\n    @Assert(doc, el.ownerDocument())\n\n    println(\"Pass5\")\n}"}
{"cj": "public func wrapNoOverflow(): Unit {\n    // 6\n    // deepChild was recursive, so could overflow if presented with a fairly insane wrap\n    var doc: Document = Document(\"https://example.com/\")\n    var el: Element = doc.body().appendElement(\"p\")\n    var num: Int64 = 50\n    var sb: StringBuilder = StringBuilder()\n    for (i in 0..=num) {\n        i\n        sb.append(\"<div>\")\n    }\n\n    el.wrap(sb.toString())\n    var html: String = doc.body().html()\n    @Assert(html.startsWith(\"<div>\"), true)\n    @Assert(num + 3, el.parents().elementArr.size)\n    println(\"Pass6\")\n}"}
{"cj": "public func Int32ToByte(dp:DataProvider):Int32 {\n \n \n    try{\n        fileheader.setFileNameW(dp.consumeString(10))\n    }catch (e:Exception) {\n        flag=-1\n    }\n    return flag\n}"}
