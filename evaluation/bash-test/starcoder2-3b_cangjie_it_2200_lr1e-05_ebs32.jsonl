{"src": "/**\n * Check if in given list of numbers, any two numbers are closer to each other than the given threshold.\n *\n * @param numbers   The collection of doubles.\n * @param threshold The threshold value for closeness comparison.\n * @return True if any two numbers are closer than the threshold, false otherwise.\n */\npublic boolean hasCloseElements(List<Double> numbers, double threshold) {\n    for (int i = 0; i < numbers.size(); i++) {\n        for (int j = i + 1; j < numbers.size(); j++) {\n            double distance = Math.abs(numbers.get(i) - numbers.get(j));\n            if (distance < threshold) return true;\n        }\n    }\n    return false;\n}", "pred": "public func hasCloseElements(numbers: ArrayList<Float64>, threshold: Float64): Bool {\n    for (i in 0..numbers.size) {\n        for (j in (i + 1)..numbers.size) {\n            let distance = math.abs(numbers[i] - numbers[j])\n            if (distance < threshold) {\n                return true\n            }\n        }\n    }\n    return false\n}\n"}
{"src": "/**\n * Input to this function is a string containing multiple groups of nested parentheses.\n * Your goal is to separate those groups into separate strings and return the list of those.\n * Separate groups are balanced (each open brace is properly closed) and not nested within each other.\n * Ignore any spaces in the input string.\n *\n * @param paren_string The string containing multiple groups of nested parentheses.\n * @return The list of separated groups of parentheses as strings.\n */\npublic List<String> separateParenGroups(String paren_string) {\n    List<String> result = new ArrayList<>();\n    StringBuilder current_string = new StringBuilder();\n    int current_depth = 0;\n\n    for (char c : paren_string.toCharArray()) {\n        if (c == '(') {\n            current_depth += 1;\n            current_string.append(c);\n        } else if (c == ')') {\n            current_depth -= 1;\n            current_string.append(c);\n\n            if (current_depth == 0) {\n                result.add(current_string.toString());\n                current_string.setLength(0);\n            }\n        }\n    }\n    return result;\n\n}", "pred": "public func separateParenGroups(paren_string: String): ArrayList<String> {\n    let result = ArrayList<String>()\n    var current_string = StringBuilder()\n    var current_depth = 0\n\n    for (c in paren_string.toRuneArray()) {\n        if (c == '(') {\n            current_depth += 1\n            current_string.append(c)\n        } else if (c == ')') {\n            current_depth -= 1\n            current_string.append(c)\n\n            if (current_depth == 0) {\n                result.append(current_string.toString())\n                current_string.clear()\n            }\n        }\n    }\n    return result\n}\n"}
{"src": "/**\n * Given a positive floating point number, it can be decomposed into an integer part\n * (largest integer smaller than the given number) and decimals (leftover part always smaller than 1).\n * Return the decimal part of the number.\n *\n * @param number The positive floating point number.\n * @return The decimal part of the number.\n */\npublic double truncateNumber(double number) {\n    return number % 1.0;\n}", "pred": "public func truncateNumber(number: Float64): Float64 {\n    return number % 1.0\n}\n"}
{"src": "/**\n * You're given a list of deposit and withdrawal operations on a bank account that starts with zero balance.\n * Your task is to detect if at any point the balance of the account falls below zero, and at that point\n * the function should return True. Otherwise, it should return False.\n *\n * @param operations The integer list of deposit and withdrawal operations.\n * @return True if the balance falls below zero at any point, false otherwise.\n */\npublic boolean belowZero(List<Integer> operations) {\n    int balance = 0;\n\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}", "pred": "func belowZero(operations: ArrayList<Int64>): Bool {\n    var balance = 0\n    for (op in operations) {\n        balance += op\n        if (balance < 0) {\n            return true\n        }\n    }\n    return false\n}\n"}
{"src": "/**\n * For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n * Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n * MAD = average | x - x_mean |\n *\n * @param numbers The list of input numbers.\n * @return The mean absolute deviation of the dataset.\n */\npublic double meanAbsoluteDeviation(List<Double> numbers) {\n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / numbers.size();\n    double sum_abs_diff = 0.0;\n    for (double num : numbers) {\n        sum_abs_diff += Math.abs(num - mean);\n    }\n    return sum_abs_diff / numbers.size();\n}", "pred": "public func meanAbsoluteDeviation(numbers: ArrayList<Float64>): Float64 {\n    var sum: Float64 = 0.0\n    for (num in numbers) {\n        sum += num\n    }\n    let mean = sum / Float64(numbers.size)\n    var sum_abs_diff: Float64 = 0.0\n    for (num in numbers) {\n        sum_abs_diff += math.abs(num - mean)\n    }\n    return sum_abs_diff / Float64(numbers.size)\n}\n"}
{"src": "/**\n * Insert a number 'delimiter' between every two consecutive elements of the input list `numbers'.\n *\n * @param numbers   The list of integers.\n * @param delimiter The number to be inserted between elements.\n * @return The list with the delimiter inserted between consecutive elements.\n */\npublic List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n    if (numbers.size() == 0) {\n        return List.of();\n    }\n    List<Integer> result = new ArrayList<>(List.of());\n    for (int i = 0; i < numbers.size() - 1; i++) {\n        result.add(numbers.get(i));\n        result.add(delimiter);\n    }\n\n    result.add(numbers.get(numbers.size() - 1));\n\n    return result;\n}", "pred": "public func intersperse(numbers: ArrayList<Int64>, delimiter: Int64): ArrayList<Int64> {\n    if (numbers.size == 0) {\n        return ArrayList<Int64>()\n    }\n    var result = ArrayList<Int64>()\n    for (i in 0..(numbers.size - 1)) {\n        result.append(numbers[i])\n        result.append(delimiter)\n    }\n\n    result.append(numbers[numbers.size - 1])\n\n    return result\n}\n"}
{"src": "/**\n * Input to this function is a string represented multiple groups of nested parentheses separated by spaces.\n * For each of the group, output the deepest level of nesting of parentheses.\n * E.g. (()()) has a maximum of two levels of nesting while ((())) has three.\n *\n * @param paren_string The string containing multiple groups of nested parentheses separated by spaces.\n * @return The list of the deepest level of nesting for each group of parentheses.\n */\npublic List<Integer> parseNestedParens(String paren_string) {\n    String[] groups = paren_string.split(\" \");\n    List<Integer> result = new ArrayList<>(List.of());\n    for (String group : groups) {\n        if (group.length() > 0) {\n            int depth = 0;\n            int max_depth = 0;\n            for (char c : group.toCharArray()) {\n                if (c == '(') {\n                    depth += 1;\n                    max_depth = Math.max(depth, max_depth);\n                } else {\n                    depth -= 1;\n                }\n            }\n            result.add(max_depth);\n        }\n    }\n    return result;\n}", "pred": "public func parseNestedParens(paren_string: String): ArrayList<Int64> {\n    let groups = paren_string.split(\" \")\n    let result = ArrayList<Int64>()\n    for (group in groups) {\n        if (group.size > 0) {\n            var depth = 0\n            var max_depth = 0\n            for (c in group.toRuneArray()) {\n                if (c == '(') {\n                    depth += 1\n                    max_depth = math.max(depth, max_depth)\n                } else {\n                    depth -= 1\n                }\n            }\n            result.append(max_depth)\n        }\n    }\n    return result\n}\n"}
{"src": "/**\n * Filter an input list of strings only for ones that contain the given substring.\n *\n * @param strings   The list of strings to filter.\n * @param substring The substring to search for in the strings.\n * @return The filtered list of strings containing the given substring.\n */\npublic List<String> filterBySubstring(List<String> strings, String substring) {\n    List<String> result = new ArrayList<>();\n    for (String x : strings) {\n        if (x.contains(substring)) {\n            result.add(x);\n        }\n    }\n    return result;\n}", "pred": "public func filterBySubstring(strings: ArrayList<String>, substring: String): ArrayList<String> {\n    var result: ArrayList<String> = ArrayList<String>()\n    for (x in strings) {\n        if (x.contains(substring)) {\n            result.append(x)\n        }\n    }\n    return result\n}\n"}
{"src": "/**\n * For a given list of integers, return a tuple consisting of a sum and a product of all the integers in the list.\n * Empty sum should be equal to 0 and empty product should be equal to 1.\n *\n * @param numbers The list of integers.\n * @return A list containing the sum and the product of all the integers in the list.\n */\npublic List<Integer> sumProduct(List<Integer> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    for (int n : numbers) {\n        sum += n;\n        product *= n;\n    }\n    return Arrays.asList(sum, product);\n}", "pred": "public func sumProduct(numbers: ArrayList<Int64>): ArrayList<Int64> {\n    var sum: Int64 = 0\n    var product: Int64 = 1\n\n    for (n in numbers) {\n        sum += n\n        product *= n\n    }\n    return ArrayList<Int64>([sum, product])\n}\n"}
{"src": "/**\n * From a given list of integers, generate a list of rolling maximum element found until the given moment in the sequence.\n *\n * @param numbers The list of integers.\n * @return The list of rolling maximum elements found until the given moment in the sequence.\n */\npublic List<Integer> rollingMax(List<Integer> numbers) {\n    List<Integer> result = new ArrayList<>();\n    if (numbers.size() == 0) {\n        return result;\n    }\n    int rollingMax = numbers.get(0);\n    result.add(rollingMax);\n\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers.get(i) > rollingMax) {\n            rollingMax = numbers.get(i);\n        }\n        result.add(rollingMax);\n    }\n\n    return result;\n}", "pred": "public func rollingMax(numbers: ArrayList<Int64>): ArrayList<Int64> {\n    let result = ArrayList<Int64>()\n    if (numbers.size == 0) {\n        return result\n    }\n    var rollingMax = numbers[0]\n    result.append(rollingMax)\n\n    for (i in 1..numbers.size) {\n        if (numbers[i] > rollingMax) {\n            rollingMax = numbers[i]\n        }\n        result.append(rollingMax)\n    }\n\n    return result\n}\n"}
{"src": "/**\n* Find the shortest palindrome that begins with a supplied string.\n* Algorithm idea is simple:\n* - Find the longest postfix of the supplied string that is a palindrome.\n* - Append to the end of the string the reverse of a string prefix that comes before the palindromic suffix.\n*\n* @param string The string to make a palindrome from.\n* @return The shortest palindrome beginning with the supplied string.\n*/\npublic boolean isPalindrome(String string) {\n    int i = 0;\n    int j = string.length() - 1;\n    while (i < j) {\n        if (string.charAt(i)!= string.charAt(j)) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n}\n\npublic String makePalindrome(String string) {\n    if (string.length() == 0) {\n        return \"\";\n    }\n\n    int beginning_of_suffix = 0;\n\n    while (!isPalindrome(string.substring(beginning_of_suffix))) {\n        beginning_of_suffix++;\n    }\n\n    return string + new StringBuffer(string.substring(0, beginning_of_suffix)).reverse().toString();\n}", "pred": "public func isPalindrome(str: String): Bool {\n    var i = 0\n    var j = str.size - 1\n    while (i < j) {\n        if (str[i]!= str[j]) {\n            return false\n        }\n        i++\n        j--\n    }\n    return true\n}\n"}
{"src": "/**\n * Input are two strings a and b consisting only of 1s and 0s.\n * Perform binary XOR on these inputs and return the result also as a string.\n *\n * @param a The first binary string.\n * @param b The second binary string.\n * @return The result of binary XOR operation on the input strings as a string.\n */\npublic String stringXor(String a, String b) {\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < a.length(); i++) {\n        if (a.charAt(i) == b.charAt(i)) {\n            result.append(\"0\");\n        } else {\n            result.append(\"1\");\n        }\n    }\n    return result.toString();\n}", "pred": "public func stringXor(a: String, b: String): String {\n    let result = StringBuilder()\n    for (i in 0..a.size) {\n        if (a[i] == b[i]) {\n            result.append(\"0\")\n        } else {\n            result.append(\"1\")\n        }\n    }\n    return result.toString()\n}\n"}
{"src": "/**\n * Out of a list of strings, return the longest one.\n * Return the first one in case of multiple strings of the same length.\n * Return None in case the input list is empty.\n *\n * @param strings The list of strings.\n * @return The optional containing the longest string, or empty if the input list is empty.\n */\npublic Optional<String> longest(List<String> strings) {\n    if (strings.isEmpty()) {\n        return Optional.empty();\n    }\n    String longest = strings.get(0);\n    for (String s : strings) {\n        if (s.length() > longest.length()) {\n            longest = s;\n        }\n    }\n    return Optional.of(longest);\n}", "pred": "public func longest(strings: ArrayList<String>): Option<String> {\n    if (strings.size == 0) {\n        return Option<String>.None\n    }\n    var longest: String = strings.get(0).getOrThrow()\n    for (s in strings) {\n        if (s.size > longest.size) {\n            longest = s\n        }\n    }\n    return Option<String>.Some(longest)\n}\n"}
{"src": "/**\n * Return the greatest common divisor of two integers a and b.\n *\n * @param a The first integer.\n * @param b The second integer.\n * @return The greatest common divisor of the two integers.\n */\npublic int greatestCommonDivisor(int a, int b) {\n    if (a == 0 || b == 0) {\n        return a + b;\n    }\n    if (a == b) {\n        return a;\n    }\n    if (a > b) {\n        return greatestCommonDivisor(a % b, b);\n    } else {\n        return greatestCommonDivisor(a, b % a);\n    }\n}", "pred": "public func greatestCommonDivisor(a: Int64, b: Int64): Int64 {\n    if (a == 0 || b == 0) {\n        return a + b\n    }\n    if (a == b) {\n        return a\n    }\n    if (a > b) {\n        return greatestCommonDivisor(a % b, b)\n    } else {\n        return greatestCommonDivisor(a, b % a)\n    }\n}\n"}
{"src": "/**\n * Return a list of all prefixes from shortest to longest of the input string.\n *\n * @param string The input string.\n * @return The list of all prefixes of the input string from shortest to longest.\n */\npublic List<String> allPrefixes(String string) {\n    List<String> result = new ArrayList<>();\n\n    for (int i = 1; i <= string.length(); i++) {\n        result.add(string.substring(0, i));\n    }\n    return result;\n}", "pred": "public func allPrefixes(string: String): ArrayList<String> {\n    var result: ArrayList<String> = ArrayList<String>()\n    for (i in 1..=string.size) {\n        result.append(string[0..i])\n    }\n    return result\n}\n"}
{"src": "/**\n * Return a string containing space-delimited numbers starting from 0 up to n inclusive.\n *\n * @param n The upper limit for the sequence.\n * @return The string containing space-delimited numbers from 0 to n.\n */\npublic String stringSequence(int n) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < n; i++) {\n        sb.append(i);\n        sb.append(\" \");\n    }\n    sb.append(n);\n    return sb.toString();\n}", "pred": "public func stringSequence(n: Int64): String {\n    let sb = StringBuilder()\n    for (i in 0..n) {\n        sb.append(i)\n        sb.append(\" \")\n    }\n    sb.append(n)\n    return sb.toString()\n}"}
{"src": "/**\n * Given a string, find out how many distinct characters (regardless of case) it consists of.\n *\n * @param string The input string.\n * @return The number of distinct characters in the string.\n */\npublic int countDistinctCharacters(String string) {\n    Set<Character> set = new HashSet<>();\n    for (char c : string.toLowerCase().toCharArray()) {\n        set.add(c);\n    }\n    return set.size();\n}", "pred": "public func countDistinctCharacters(string: String): Int64 {\n    let set = HashSet<Char>()\n    for (c in string.toAsciiLower().toRuneArray()) {\n        set.put(c)\n    }\n    return set.size\n}\n"}
{"src": "/**\n * Input to this function is a string representing musical notes in a special ASCII format.\n * Your task is to parse this string and return a list of integers corresponding to how many beats each note lasts.\n * Here is a legend:\n * \"o\" - whole note, lasts four beats\n * \"o|\" - half note, lasts two beats\n * \".|\" - quarter note, lasts one beat\n *\n * @param string The input string representing musical notes.\n * @return The list of integers corresponding to how many beats each note lasts.\n */\npublic List<Integer> parseMusic(String string) {\n    String[] notes = string.split(\" \");\n    List<Integer> result = new ArrayList<>();\n    for (String s : notes) {\n        switch (s) {\n            case \"o\" -> result.add(4);\n            case \"o|\" -> result.add(2);\n            case \".|\" -> result.add(1);\n        }\n    }\n    return result;\n}", "pred": "public func parseMusic(string: String): ArrayList<Int64> {\n    let notes = string.split(\" \")\n    var result = ArrayList<Int64>()\n    for (s in notes) {\n        match (s) {\n            case \"o\" => result.append(4)\n            case \"o|\" => result.append(2)\n            case \".|\" => result.append(1)\n            case _ => ()\n        }\n    }\n    return result\n}\n"}
{"src": "/**\n * Find how many times a given substring can be found in the original string. Count overlapping cases.\n *\n * @param string    The original string.\n * @param substring The substring to search for.\n * @return The number of times the substring can be found in the original string.\n */\npublic int howManyTimes(String string, String substring) {\n    int times = 0;\n\n    for (int i = 0; i < string.length() - substring.length() + 1; i++) {\n        if (string.substring(i, i + substring.length()).equals(substring)) {\n            times += 1;\n        }\n    }\n\n    return times;\n}", "pred": "public func howManyTimes(string: String, substring: String): Int64 {\n    var times: Int64 = 0\n    for (i in 0..(string.size - substring.size + 1)) {\n        if (string[i..(i + substring.size)] == substring) {\n            times += 1\n        }\n    }\n    return times\n}\n"}
{"src": "/**\n * Input is a space-delimited string of numerals from 'zero' to 'nine'.\n * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', and 'nine'.\n * Return the string with numbers sorted from smallest to largest.\n *\n * @param numbers The space-delimited string of numerals.\n * @return The sorted string of numerals.\n */\npublic String sortNumbers(String numbers) {\n    String[] nums = numbers.split(\" \");\n    List<Integer> num = new ArrayList<>();\n    for (String string : nums) {\n        switch (string) {\n            case \"zero\" -> num.add(0);\n            case \"one\" -> num.add(1);\n            case \"two\" -> num.add(2);\n            case \"three\" -> num.add(3);\n            case \"four\" -> num.add(4);\n            case \"five\" -> num.add(5);\n            case \"six\" -> num.add(6);\n            case \"seven\" -> num.add(7);\n            case \"eight\" -> num.add(8);\n            case \"nine\" -> num.add(9);\n        }\n    }\n    Collections.sort(num);\n    List<String> result = new ArrayList<>();\n    for (int m : num) {\n        switch (m) {\n            case 0 -> result.add(\"zero\");\n            case 1 -> result.add(\"one\");\n            case 2 -> result.add(\"two\");\n            case 3 -> result.add(\"three\");\n            case 4 -> result.add(\"four\");\n            case 5 -> result.add(\"five\");\n            case 6 -> result.add(\"six\");\n            case 7 -> result.add(\"seven\");\n            case 8 -> result.add(\"eight\");\n            case 9 -> result.add(\"nine\");\n        }\n    }\n    return String.join(\" \", result);\n}", "pred": "public func sortNumbers(numbers: String): String {\n    let nums = numbers.split(\" \")\n    let num = ArrayList<Int64>()\n    for (string in nums) {\n        match (string) {\n            case \"zero\" => num.append(0)\n            case \"one\" => num.append(1)\n            case \"two\" => num.append(2)\n            case \"three\" => num.append(3)\n            case \"four\" => num.append(4)\n            case \"five\" => num.append(5)\n            case \"six\" => num.append(6)\n            case \"seven\" => num.append(7)\n            case \"eight\" => num.append(8)\n            case \"nine\" => num.append(9)\n            case _ => ()\n        }\n    }\n    num.sortBy({ a: Int64, b: Int64 =>\n        if (a < b) {\n            return Ordering.LT\n        }\n        if (a > b) {\n            return Ordering.GT\n        }\n        return Ordering.EQ\n    })\n    let result = ArrayList<String>()\n    for (m in num) {\n        match (m) {\n            case 0 => result.append(\"zero\")\n            case 1 => result.append(\"one\")\n            case 2 => result.append(\"two\")\n            case 3 => result.append(\"three\")\n            case 4 => result.append(\"four\")\n            case 5 => result.append(\"five\")\n            case 6 => result.append(\"six\")\n            case 7 => result.append(\"seven\")\n            case 8 => result.append(\"eight\")\n            case 9 => result.append(\"nine\")\n            case _ => ()\n        }\n    }\n    return result.joinToString(\" \")\n}\n"}
{"src": "/**\n * From a supplied list of numbers (of length at least two), select and return two that are the closest to each other\n * and return them in order (smaller number, larger number).\n *\n * @param numbers The list of numbers.\n * @return The two numbers that are closest to each other.\n */\npublic List<Double> findClosestElements(List<Double> numbers) {\n    List<Double> closest_pair = new ArrayList<>();\n    closest_pair.add(numbers.get(0));\n    closest_pair.add(numbers.get(1));\n    double distance = Math.abs(numbers.get(1) - numbers.get(0));\n    for (int i = 0; i < numbers.size(); i++) {\n        for (int j = i + 1; j < numbers.size(); j++) {\n            if (Math.abs(numbers.get(i) - numbers.get(j)) < distance) {\n                closest_pair.clear();\n                closest_pair.add(numbers.get(i));\n                closest_pair.add(numbers.get(j));\n                distance = Math.abs(numbers.get(i) - numbers.get(j));\n            }\n        }\n    }\n    Collections.sort(closest_pair);\n    return closest_pair;\n}", "pred": "public func findClosestElements(numbers: ArrayList<Float64>): ArrayList<Float64> {\n    var closest_pair: ArrayList<Float64> = ArrayList<Float64>()\n    closest_pair.append(numbers[0])\n    closest_pair.append(numbers[1])\n    var distance: Float64 = math.abs(numbers[1] - numbers[0])\n    for (i in 0..numbers.size) {\n        for (j in i + 1..numbers.size) {\n            if (math.abs(numbers[i] - numbers[j]) < distance) {\n                closest_pair.clear()\n                closest_pair.append(numbers[i])\n                closest_pair.append(numbers[j])\n                distance = math.abs(numbers[i] - numbers[j])\n            }\n        }\n    }\n    closest_pair.sortBy({ a: Float64, b: Float64 =>\n        if (a < b) {\n            return Ordering.LT\n        }\n        if (a > b) {\n            return Ordering.GT\n        }\n        return Ordering.EQ\n    })\n    return closest_pair\n}\n"}
{"src": "/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n * such that the smallest number will become 0 and the largest will become 1.\n *\n * @param numbers The list of numbers to rescale.\n * @return The list of numbers after applying the linear transformation.\n */\npublic List<Double> rescaleToUnit(List<Double> numbers) {\n    double min_number = Collections.min(numbers);\n    double max_number = Collections.max(numbers);\n    List<Double> result = new ArrayList<>();\n    for (double x : numbers) {\n        result.add((x - min_number) / (max_number - min_number));\n    }\n    return result;\n}", "pred": "public func rescaleToUnit(numbers: ArrayList<Float64>): ArrayList<Float64> {\n    let min_number = min(numbers)\n    let max_number = max(numbers)\n    let result = ArrayList<Float64>()\n    for (x in numbers) {\n        result.append((x - min_number) / (max_number - min_number))\n    }\n    return result\n}\n"}
{"src": "/**\n * Filter given list of any values only for integers.\n *\n * @param values The list of values to filter.\n * @return The list containing only the integers from the input list.\n */\npublic List<Integer> filterIntergers(List<Object> values) {\n    List<Integer> result = new ArrayList<>();\n    for (Object x : values) {\n        if (x instanceof Integer) {\n            result.add((Integer) x);\n        }\n    }\n    return result;\n}", "pred": "public func filterIntergers(values: ArrayList<Any>): ArrayList<Int64> {\n    let result = ArrayList<Int64>()\n    for (x in values) {\n        if (x is Int64) {\n            result.append(x as Int64)\n        }\n    }\n    return result\n}"}
{"src": "/**\n * Return the length of the given string.\n *\n * @param string The input string.\n * @return The length of the string.\n */\npublic int strlen(String string) {\n    return string.length();\n}", "pred": "public func strlen(string: String): Int32 {\n    return Int32(string.size)\n}"}
{"src": "/**\n * For a given number n, find the largest number that divides n evenly, smaller than n.\n *\n * @param n The input number.\n * @return The largest divisor of n that is smaller than n itself.\n */\npublic int largestDivisor(int n) {\n    for (int i = n - 1; i > 0; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}", "pred": "func largestDivisor(n: Int64): Int64 {\n    for (i in (n - 1)..=0 : -1) {\n        if (n % i == 0) {\n            return i\n        }\n    }\n    return 1\n}\n"}
{"src": "/**\n * Return a list of prime factors of the given integer in the order from smallest to largest.\n * Each of the factors should be listed the number of times corresponding to how many times it appears in factorization.\n * Input number should be equal to the product of all factors.\n *\n * @param n The input integer to factorize.\n * @return The list of prime factors of the input integer.\n */\npublic List<Integer> factorize(int n) {\n    List<Integer> fact = new ArrayList<>();\n    int i = 2;\n    while (n > 1) {\n        if (n % i == 0) {\n            fact.add(i);\n            n /= i;\n        } else {\n            i++;\n        }\n    }\n    return fact;\n}", "pred": "public func factorize(n: Int64): ArrayList<Int64> {\n    var fact: ArrayList<Int64> = ArrayList<Int64>()\n    var i = 2\n    while (n > 1) {\n        if (n % i == 0) {\n            fact.append(i)\n            n /= i\n        } else {\n            i++\n        }\n    }\n    return fact\n}\n"}
{"src": "/**\n * From a list of integers, remove all elements that occur more than once.\n * Keep the order of elements left the same as in the input.\n *\n * @param numbers The list of integers.\n * @return The list of integers with duplicates removed.\n */\npublic List<Integer> removeDuplicates(List<Integer> numbers) {\n    Map<Integer, Integer> c = new HashMap<>();\n    for (int i : numbers) {\n        c.put(i, c.getOrDefault(i, 0) + 1);\n    }\n    return numbers.stream().filter(i -> c.get(i) == 1).collect(Collectors.toList());\n}", "pred": "public func removeDuplicates(numbers: ArrayList<Int64>): ArrayList<Int64> {\n    var c = HashMap<Int64, Int64>()\n    for (i in numbers) {\n        if (c.contains(i)) {\n            c[i] = c[i] + 1\n        } else {\n            c[i] = 1\n        }\n    }\n    var result = ArrayList<Int64>()\n    for (i in numbers) {\n        if (c[i] == 1) {\n            result.append(i)\n        }\n    }\n    return result\n}\n"}
{"src": "/**\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n *\n * @param string The input string.\n * @return The string with flipped case characters.\n */\npublic String flipCase(String string) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < string.length(); i++) {\n        if (Character.isLowerCase(string.charAt(i))) {\n            sb.append(Character.toUpperCase(string.charAt(i)));\n        } else {\n            sb.append(Character.toLowerCase(string.charAt(i)));\n        }\n    }\n    return sb.toString();\n}", "pred": "public func flipCase(string: String): String {\n    let sb = StringBuilder()\n    for (i in 0..string.size) {\n        if (string[i].isAsciiLower()) {\n            sb.append(string[i].toAsciiUpper())\n        } else {\n            sb.append(string[i].toAsciiLower())\n        }\n    }\n    return sb.toString()\n}\n"}
{"src": "/**\n * Concatenate a list of strings into a single string.\n *\n * @param strings The list of strings to concatenate.\n * @return The concatenated string.\n */\npublic String concatenate(List<String> strings) {\n    return String.join(\"\", strings);\n}", "pred": "public func concatenate(strings: ArrayList<String>): String {\n    var result: String = \"\"\n    for (str in strings) {\n        result += str\n    }\n    return result\n}\n"}
{"src": "/**\n * Filter an input list of strings only for ones that start with a given prefix.\n *\n * @param strings The list of strings to filter.\n * @param prefix  The prefix to search for at the start of strings.\n * @return The filtered list of strings starting with the given prefix.\n */\npublic List<String> filterByPrefix(List<String> strings, String prefix) {\n    return strings.stream().filter(p -> p.startsWith(prefix)).collect(Collectors.toList());\n}", "pred": "public func filterByPrefix(strings: ArrayList<String>, prefix: String): ArrayList<String> {\n    var result: ArrayList<String> = ArrayList<String>()\n    for (str in strings) {\n        if (str.startsWith(prefix)) {\n            result.append(str)\n        }\n    }\n    return result\n}\n"}
{"src": "/**\n * Return only positive numbers in the list.\n *\n * @param l The list of integers.\n * @return The list containing only positive numbers.\n */\npublic List<Integer> getPositive(List<Integer> l) {\n    return l.stream().filter(p -> p > 0).collect(Collectors.toList());\n}", "pred": "public func getPositive(l: ArrayList<Int64>): ArrayList<Int64> {\n    var positiveList = ArrayList<Int64>()\n    for (i in 0..l.size) {\n        if (l[i] > 0) {\n            positiveList.append(l[i])\n        }\n    }\n    return positiveList\n}\n"}
{"src": "/**\n * Return true if a given number is prime, and false otherwise.\n *\n * @param n The number to check for primality.\n * @return True if the number is prime, false otherwise.\n */\npublic boolean isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    for (int k = 2; k < n; k++) {\n        if (n % k == 0) {\n            return false;\n        }\n    }\n     return true;\n}", "pred": "func isPrime(n: Int64): Bool {\n    if (n < 2) {\n        return false\n    }\n    for (k in 2..n) {\n        if (n % k == 0) {\n            return false\n        }\n    }\n    return true\n}\n"}
{"src": "/**\n* Find x such that poly(x) = 0.\n* findZero returns only one zero point, even if there are many.\n* Moreover, findZero only takes a list xs having an even number of coefficients and largest non-zero coefficient,\n* as it guarantees a solution.\n*\n* @param xs The list of coefficients of the polynomial.\n* @return The zero point of the polynomial.\n*/\npublic double poly(List<Double> xs, double x) {\n    double result = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        result += xs.get(i) * Math.pow(x, i);\n    }\n    return result;\n}\n\npublic double findZero(List<Double> xs) {\n    double begin = -1, end = 1;\n    while (poly(xs, begin) * poly(xs, end) > 0) {\n        begin *= 2;\n        end *= 2;\n    }\n    while (end - begin > 1e-10) {\n        double center = (begin + end) / 2;\n        if (poly(xs, begin) * poly(xs, center) > 0) {\n            begin = center;\n        } else {\n            end = center;\n        }\n    }\n    return begin;\n}", "pred": "public func poly(xs: ArrayList<Float64>, x: Float64): Float64 {\n    var result: Float64 = 0.0\n    for (i in 0..xs.size) {\n        result += xs[i] * pow(x, Float64(i))\n    }\n    return result\n}\n\npublic func findZero(xs: ArrayList<Float64>): Float64 {\n    var begin: Float64 = -1.0\n    var end: Float64 = 1.0\n    while (poly(xs, begin) * poly(xs, end) > 0.0) {\n        begin *= 2.0\n        end *= 2.0\n    }\n    while (end - begin > 1e-10) {\n        let center = (begin + end) / 2.0\n        if (poly(xs, begin) * poly(xs, center) > 0.0) {\n            begin = center\n        } else {\n            end = center\n        }\n    }\n    return begin\n}\n"}
{"src": "/**\n * This function takes a list l and returns a list l' such that l' is identical to l in the indices\n * that are not divisible by three, while its values at the indices that are divisible by three\n * are equal to the values of the corresponding indices of l, but sorted.\n *\n * @param l The input list of integers.\n * @return The modified list with values sorted at indices divisible by three.\n */\npublic List<Integer> sortThird(List<Integer> l) {\n    List<Integer> thirds = new ArrayList<>();\n    for (int i = 0; i < l.size(); i += 3) {\n        thirds.add(l.get(i));\n    }\n    Collections.sort(thirds);\n    List<Integer> result = l;\n    for (int i = 0; i < l.size(); i += 3) {\n        result.set(i, thirds.get(i / 3));\n    }\n    return result;\n}", "pred": "public func sortThird(l: ArrayList<Int64>): ArrayList<Int64> {\n    var thirds = ArrayList<Int64>()\n    for (i in 0..l.size : 3) {\n        thirds.append(l[i])\n    }\n    thirds.sortBy({a: Int64, b: Int64 =>\n        if (a < b) {\n            return Ordering.LT\n        }\n        if (a > b) {\n            return Ordering.GT\n        }\n        return Ordering.EQ\n    })\n    var result = l\n    for (i in 0..l.size : 3) {\n        result[i] = thirds[i / 3]\n    }\n    return result\n}\n"}
{"src": "/**\n * Return sorted unique elements in a list.\n *\n * @param l The list of integers.\n * @return The sorted list of unique elements.\n */\npublic List<Integer> unique(List<Integer> l) {\n    List<Integer> result = new ArrayList<>(new HashSet<>(l));\n    Collections.sort(result);\n    return result;\n}", "pred": "public func unique(l: ArrayList<Int64>): ArrayList<Int64> {\n    let result = ArrayList<Int64>(HashSet<Int64>(l))\n    result.sortBy({a: Int64, b: Int64 =>\n        if (a < b) {\n            return Ordering.LT\n        }\n        if (a > b) {\n            return Ordering.GT\n        }\n        return Ordering.EQ\n    })\n    return result\n}\n"}
{"src": "/**\n * Return the maximum element in the list.\n *\n * @param l The list of integers.\n * @return The maximum element in the list.\n */\npublic int maxElement(List<Integer> l) {\n    return Collections.max(l);\n}", "pred": "public func maxElement(l: ArrayList<Int64>): Int64 {\n    return l.max()?? 0\n}\n"}
{"src": "/**\n * Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n *\n * @param n The upper limit (exclusive) for checking numbers.\n * @return The number of times the digit 7 appears in numbers less than n divisible by 11 or 13.\n */\npublic int fizzBuzz(int n) {\n    int result = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            char[] digits = String.valueOf(i).toCharArray();\n            for (char c : digits) {\n                if (c == '7') {\n                    result += 1;\n                }\n            }\n        }\n    }\n    return result;\n}", "pred": "func fizzBuzz(n: Int64): Int64 {\n    var result = 0\n    for (i in 1..n) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            let digits = i.toString().toRuneArray()\n            for (c in digits) {\n                if (c == '7') {\n                    result += 1\n                }\n            }\n        }\n    }\n    return result\n}\n"}
{"src": "/**\n * This function takes a list l and returns a list l' such that l' is identical to l in the odd indices,\n * while its values at the even indices are equal to the values of the even indices of l, but sorted.\n *\n * @param l The input list of integers.\n * @return The modified list with values sorted at even indices.\n */\npublic List<Integer> sortEven(List<Integer> l) {\n    List<Integer> even = new ArrayList<>();\n    for (int i = 0; i < l.size(); i += 2) {\n        even.add(l.get(i));\n    }\n    Collections.sort(even);\n    List<Integer> result = l;\n    for (int i = 0; i < l.size(); i += 2) {\n        result.set(i, even.get(i / 2));\n    }\n    return result;\n}", "pred": "public func sortEven(l: ArrayList<Int64>): ArrayList<Int64> {\n    var even: ArrayList<Int64> = ArrayList<Int64>()\n    for (i in 0..l.size : 2) {\n        even.append(l[i])\n    }\n    even.sortBy({a: Int64, b: Int64 =>\n        if (a < b) {\n            return Ordering.LT\n        }\n        if (a > b) {\n            return Ordering.GT\n        }\n        return Ordering.EQ\n    })\n    var result: ArrayList<Int64> = l\n    for (i in 0..l.size : 2) {\n        result[i] = even[i / 2]\n    }\n    return result\n}\n"}
{"src": "/**\n* Takes as input a string encoded with encodeCyclic function and returns the decoded string.\n*\n* @param s The encoded string to decode.\n* @return The decoded string.\n*/\npublic String decodeCyclic(String s) {\n    return encodeCyclic(encodeCyclic(s));\n}", "pred": "public func decodeCyclic(s: String): String {\n    return encodeCyclic(encodeCyclic(s))\n}"}
{"src": "/**\n * primeFib returns the n-th number that is a Fibonacci number and is also prime.\n *\n * @param n The position of the prime Fibonacci number to find.\n * @return The n-th prime Fibonacci number.\n */\npublic int primeFib(int n) {\n    int f0 = 0, f1 = 1;\n    while (true) {\n        int p = f0 + f1;\n        boolean is_prime = p >= 2;\n        for (int k = 2; k < Math.min(Math.sqrt(p) + 1, p - 1); k++) {\n            if (p % k == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            n -= 1;\n        }\n        if (n == 0) {\n            return p;\n        }\n        f0 = f1;\n        f1 = p;\n    }\n}", "pred": "func primeFib(n: Int64): Int64 {\n    var f0: Int64 = 0\n    var f1: Int64 = 1\n    while (true) {\n        let p = f0 + f1\n        var is_prime = p >= 2\n        for (k in 2..(math.min(math.sqrt(Float64(p)) + 1, Float64(p - 1)))) {\n            if (p % k == 0) {\n                is_prime = false\n                break\n            }\n        }\n        if (is_prime) {\n            n -= 1\n        }\n        if (n == 0) {\n            return p\n        }\n        f0 = f1\n        f1 = p\n    }\n}\n"}
{"src": "/**\n * triplesSumToZero takes a list of integers as input. It returns true if there are three distinct elements\n * in the list that sum to zero, and false otherwise.\n *\n * @param l The list of integers.\n * @return True if there are three distinct elements that sum to zero, false otherwise.\n */\npublic boolean triplesSumToZero(List<Integer> l) {\n    for (int i = 0; i < l.size(); i++) {\n        for (int j = i + 1; j < l.size(); j++) {\n            for (int k = j + 1; k < l.size(); k++) {\n                if (l.get(i) + l.get(j) + l.get(k) == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}", "pred": "public func triplesSumToZero(l: ArrayList<Int64>): Bool {\n    for (i in 0..l.size) {\n        for (j in i + 1..l.size) {\n            for (k in j + 1..l.size) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n"}
{"src": "/**\n * Imagine a road that's a perfectly straight infinitely long line. n cars are driving left to right;\n * simultaneously, a different set of n cars are driving right to left. The two sets of cars start out\n * being very far from each other. All cars move at the same speed. Two cars are said to collide when\n * a car that's moving left to right hits a car that's moving right to left. However, the cars are\n * infinitely sturdy and strong; as a result, they continue moving in their trajectory as if they did\n * not collide. This function outputs the number of such collisions.\n *\n * @param n The number of cars in each direction.\n * @return The number of collisions.\n */\npublic int carRaceCollision(int n) {\n    return n * n;\n}", "pred": "func carRaceCollision(n: Int64): Int64 {\n    return n * n\n}\n"}
{"src": "/**\n * Return a list with elements incremented by 1.\n *\n * @param l The list of integers.\n * @return The list with elements incremented by 1.\n */\npublic List<Integer> incrList(List<Integer> l) {\n    return l.stream().map(p -> p + 1).collect(Collectors.toList());\n}", "pred": "public func incrList(l: ArrayList<Int64>): ArrayList<Int64> {\n    var newList = ArrayList<Int64>()\n    for (i in 0..l.size) {\n        newList.append(l[i] + 1)\n    }\n    return newList\n}\n"}
{"src": "/**\n * pairsSumToZero takes a list of integers as input. It returns true if there are two distinct elements\n * in the list that sum to zero, and false otherwise.\n *\n * @param l The list of integers.\n * @return True if there are two distinct elements that sum to zero, false otherwise.\n */\npublic boolean pairsSumToZero(List<Integer> l) {\n    for (int i = 0; i < l.size(); i++) {\n        for (int j = i + 1; j < l.size(); j++) {\n            if (l.get(i) + l.get(j) == 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "pred": "public func pairsSumToZero(l: ArrayList<Int64>): Bool {\n    for (i in 0..l.size) {\n        for (j in i + 1..l.size) {\n            if (l[i] + l[j] == 0) {\n                return true\n            }\n        }\n    }\n    return false\n}\n"}
{"src": "/**\n * Change numerical base of input number x to base. Return string representation after the conversion.\n * Base numbers are less than 10.\n *\n * @param x    The input number.\n * @param base The base to convert to.\n * @return The string representation after the conversion.\n */\npublic String changeBase(int x, int base) {\n    StringBuilder ret = new StringBuilder();\n    while (x > 0) {\n        ret.append(String.valueOf(x % base));\n        x /= base;\n    }\n    return ret.reverse().toString();\n}", "pred": "public func changeBase(x: Int64, base: Int64): String {\n    var ret: StringBuilder = StringBuilder()\n    var x1 = x\n    while (x1 > 0) {\n        ret.append(x1 % base)\n        x1 /= base\n    }\n    return ret.toString().toRuneArray().reverse().toString()\n}\n"}
{"src": "/**\n * Given the length of a side and height, return the area for a triangle.\n *\n * @param a The length of the base side.\n * @param h The height of the triangle.\n * @return The area of the triangle.\n */\npublic double triangleArea(double a, double h) {\n    return a * h / 2;\n}", "pred": "public func triangleArea(a: Float64, h: Float64): Float64 {\n    return a * h / 2.0\n}\n"}
{"src": "/**\n * The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n * fib4(0) -> 0\n * fib4(1) -> 0\n * fib4(2) -> 2\n * fib4(3) -> 0\n * fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n * Please write a function to efficiently compute the n-th element of the fib4 number sequence.\n * Do not use recursion.\n *\n * @param n The index of the Fibonacci number to compute.\n * @return The n-th element of the fib4 number sequence.\n */\npublic int fib4(int n) {\n    List<Integer> results = new ArrayList<>();\n    results.add(0);\n    results.add(0);\n    results.add(2);\n    results.add(0);\n    if (n < 4) {\n        return results.get(n);\n    }\n\n    for (int i = 4; i <= n; i++) {\n        results.add(results.get(0) + results.get(1) + results.get(2) + results.get(3));\n        results.remove(0);\n    }\n    return results.get(3);\n}", "pred": "public func fib4(n: Int64): Int64 {\n    var results = ArrayList<Int64>()\n    results.append(0)\n    results.append(0)\n    results.append(2)\n    results.append(0)\n    if (n < 4) {\n        return results[n]\n    }\n\n    for (i in 4..=n) {\n        results.append(results[0] + results[1] + results[2] + results[3])\n        results.remove(0)\n    }\n    return results[3]\n}\n"}
{"src": "/**\n * Return the median of elements in the list l.\n *\n * @param l The list of integers.\n * @return The median of the elements in the list.\n */\npublic double median(List<Integer> l) {\n    List<Integer> list = l;\n    Collections.sort(list);\n    if (l.size() % 2 == 1) {\n        return l.get(l.size() / 2);\n    } else {\n        return (l.get(l.size() / 2 - 1) + l.get(l.size() / 2)) / 2.0;\n    }\n}", "pred": "public func median(l: ArrayList<Int64>): Float64 {\n    var list: ArrayList<Int64> = l\n    list.sortBy({ rht: Int64, lht: Int64 =>\n        if (rht < lht) {\n            return Ordering.LT\n        }\n        if (rht > lht) {\n            return Ordering.GT\n        }\n        return Ordering.EQ\n    })\n    if (list.size % 2 == 1) {\n        return Float64(list[list.size / 2])\n    } else {\n        return Float64((list[list.size / 2 - 1] + list[list.size / 2])) / 2.0\n    }\n}\n"}
{"src": "/**\n * Checks if the given string is a palindrome.\n *\n * @param text The input string to check.\n * @return True if the string is a palindrome, false otherwise.\n */\npublic boolean isPalindrome(String text) {\n    for (int i = 0; i < text.length(); i++) {\n        if (text.charAt(i) != text.charAt(text.length() - 1 - i)) {\n            return false;\n        }\n    }\n    return true;\n}", "pred": "public func isPalindrome(text: String): Bool {\n    for (i in 0..text.size) {\n        if (text[i]!= text[text.size - 1 - i]) {\n            return false\n        }\n    }\n    return true\n}\n"}
{"src": "/**\n * Return 2^n modulo p (be aware of numerics).\n *\n * @param n The exponent.\n * @param p The modulo base.\n * @return The result of 2^n modulo p.\n */\npublic int modp(int n, int p) {\n    int ret = 1;\n    for (int i = 0; i < n; i++) {\n        ret = (ret * 2) % p;\n    }\n    return ret;\n}", "pred": "func modp(n: Int64, p: Int64): Int64 {\n    var ret: Int64 = 1\n    for (i in 0..n) {\n        ret = (ret * 2) % p\n    }\n    return ret\n}\n"}
{"src": "/**\n* Takes as input a string encoded with the encodeShift function. Returns the decoded string.\n*\n* @param s The input string to decode.\n* @return The decoded string.\n*/\npublic String decodeShift(String s) {\n    StringBuilder sb = new StringBuilder();\n    for (char ch : s.toCharArray()) {\n        sb.append((char) ('a' + ((ch + 21 - 'a') % 26)));\n    }\n    return sb.toString();\n}", "pred": "public func decodeShift(s: String): String {\n    let sb = StringBuilder()\n    for (ch in s.toRuneArray()) {\n        sb.append(Char(UInt32('a') + ((UInt32(ch) + 21 - UInt32('a')) % 26)))\n    }\n    return sb.toString()\n}"}
{"src": "/**\n * removeVowels is a function that takes a string and returns a string without vowels.\n *\n * @param text The input string.\n * @return The string without vowels.\n */\npublic String removeVowels(String text) {\n    StringBuilder sb = new StringBuilder();\n    for (char ch : text.toCharArray()) {\n        if (\"aeiou\".indexOf(Character.toLowerCase(ch)) == -1) {\n            sb.append(ch);\n        }\n    }\n    return sb.toString();\n}", "pred": "public func removeVowels(text: String): String {\n    let sb = StringBuilder()\n    for (ch in text.toAsciiLower().toRuneArray()) {\n        if (\"aeiou\".indexOf(ch) == -1) {\n            sb.append(ch)\n        }\n    }\n    return sb.toString()\n}\n"}
{"src": "/**\n * Return true if all numbers in the list l are below threshold t.\n *\n * @param l The list of integers.\n * @param t The threshold value.\n * @return True if all numbers are below the threshold, false otherwise.\n */\npublic boolean belowThreshold(List<Integer> l, int t) {\n    for (int e : l) {\n        if (e >= t) {\n            return false;\n        }\n    }\n    return true;\n}", "pred": "public func belowThreshold(l: ArrayList<Int64>, t: Int64): Bool {\n    for (e in l) {\n        if (e >= t) {\n            return false\n        }\n    }\n    return true\n}\n"}
{"src": "/**\n * Add two numbers x and y.\n *\n * @param x The first number.\n * @param y The second number.\n * @return The sum of x and y.\n */\npublic int add(int x, int y) {\n    return x + y;\n}", "pred": "public func add(x: Int64, y: Int64): Int64 {\n    return x + y\n}"}
{"src": "/**\n * Check if two words have the same characters.\n *\n * @param s0 The first word.\n * @param s1 The second word.\n * @return True if the words have the same characters, false otherwise.\n */\npublic boolean sameChars(String s0, String s1) {\n    Set<Character> set0 = new HashSet<>();\n    for (char c : s0.toCharArray()) {\n        set0.add(c);\n    }\n    Set<Character> set1 = new HashSet<>();\n    for (char c : s1.toCharArray()) {\n        set1.add(c);\n    }\n    return set0.equals(set1);\n}", "pred": "public func sameChars(s0: String, s1: String): Bool {\n    let set0 = HashSet<Char>()\n    for (c in s0.toRuneArray()) {\n        set0.put(c)\n    }\n    let set1 = HashSet<Char>()\n    for (c in s1.toRuneArray()) {\n        set1.put(c)\n    }\n    return set0 == set1\n}\n"}
{"src": "/**\n * Return the n-th Fibonacci number.\n *\n * @param n The index of the Fibonacci number to return.\n * @return The n-th Fibonacci number.\n */\npublic int fib(int n) {\n    if (n == 0) {\n        return 0;\n    }\n    if (n == 1) {\n        return 1;\n    }\n    return fib(n - 1) + fib(n - 2);\n}", "pred": "func fib(n: Int64): Int64 {\n    if (n == 0) {\n        return 0\n    }\n    if (n == 1) {\n        return 1\n    }\n    return fib(n - 1) + fib(n - 2)\n}\n"}
{"src": "/**\n * brackets is a string of \"<\" and \">\". Return true if every opening bracket has a corresponding closing bracket.\n *\n * @param brackets The string of brackets.\n * @return True if every opening bracket has a corresponding closing bracket, false otherwise.\n */\npublic boolean correctBracketing(String brackets) {\n    int depth = 0;\n    for (char b : brackets.toCharArray()) {\n        if (b == '<') {\n            depth += 1;\n        } else {\n            depth -= 1;\n        }\n        if (depth < 0) {\n            return false;\n        }\n    }\n    return depth == 0;\n}", "pred": "public func correctBracketing(brackets: String): Bool {\n    var depth = 0\n    for (b in brackets.toRuneArray()) {\n        if (b == '<') {\n            depth += 1\n        } else {\n            depth -= 1\n        }\n        if (depth < 0) {\n            return false\n        }\n    }\n    return depth == 0\n}\n"}
{"src": "/**\n * Return true if list elements are monotonically increasing or decreasing.\n *\n * @param l The list of integers.\n * @return True if the list is monotonically increasing or decreasing, false otherwise.\n */\npublic boolean monotonic(List<Integer> l) {\n    List<Integer> l1 = new ArrayList<>(l), l2 = new ArrayList<>(l);\n    Collections.sort(l1);\n    l2.sort(Collections.reverseOrder());\n    return l.equals(l1) || l.equals(l2);\n}", "pred": "public func monotonic(l: ArrayList<Int64>): Bool {\n    var l1 = l\n    var l2 = l\n    l1.sortBy({x: Int64 => x})\n    l2.sortBy({x: Int64 => -x})\n    return l == l1 || l == l2\n}\n"}
{"src": "/**\n * Return sorted unique common elements for two lists.\n *\n * @param l1 The first list of integers.\n * @param l2 The second list of integers.\n * @return A list containing sorted unique common elements between l1 and l2.\n */\npublic List<Integer> common(List<Integer> l1, List<Integer> l2) {\n    Set<Integer> ret = new HashSet<>(l1);\n    ret.retainAll(new HashSet<>(l2));\n    List<Integer> result = new ArrayList<>(ret);\n    Collections.sort(result);\n    return result;\n}", "pred": "public func common(l1: ArrayList<Int64>, l2: ArrayList<Int64>): ArrayList<Int64> {\n    let ret = HashSet<Int64>(l1)\n    ret.retainAll(l2)\n    let result = ArrayList<Int64>(ret)\n    result.sortBy({x: Int64, y: Int64 =>\n        if (x < y) {\n            return Ordering.LT\n        }\n        if (x > y) {\n            return Ordering.GT\n        }\n        return Ordering.EQ\n    })\n    return result\n}\n"}
{"src": "/**\n * Return the largest prime factor of n.\n * Assume n > 1 and is not a prime.\n *\n * @param n The number for which the largest prime factor needs to be found.\n * @return The largest prime factor of n.\n */\npublic int largestPrimeFactor(int n) {\n    int largest = 1;\n    for (int j = 2; j <= n; j++) {\n        if (n % j == 0) {\n            boolean is_prime = j >= 2;\n            for (int i = 2; i < j - 1; i++) {\n                if (j % i == 0) {\n                    is_prime = false;\n                    break;\n                }\n            }\n            if (is_prime) {\n                largest = Math.max(largest, j);\n            }\n        }\n    }\n    return largest;\n}", "pred": "func largestPrimeFactor(n: Int64): Int64 {\n    var largest: Int64 = 1\n    for (j in 2..=n) {\n        if (n % j == 0) {\n            var is_prime: Bool = j >= 2\n            for (i in 2..(j - 1)) {\n                if (j % i == 0) {\n                    is_prime = false\n                    break\n                }\n            }\n            if (is_prime) {\n                largest = math.max(largest, j)\n            }\n        }\n    }\n    return largest\n}\n"}
{"src": "/**\n * sumToN is a function that sums numbers from 1 to n.\n *\n * @param n The upper limit of the numbers to be summed.\n * @return The sum of numbers from 1 to n.\n */\npublic int sumToN(int n) {\n    int result = 0;\n    for (int i = 1; i <= n; i++) {\n        result += i;\n    }\n    return result;\n}", "pred": "func sumToN(n: Int64): Int64 {\n    var result: Int64 = 0\n    for (i in 1..=n) {\n        result += i\n    }\n    return result\n}\n"}
{"src": "/**\n * brackets is a string of \"(\" and \")\". Return true if every opening bracket has a corresponding closing bracket.\n *\n * @param brackets The string of brackets to check.\n * @return True if every opening bracket has a corresponding closing bracket, otherwise false.\n */\npublic boolean correctBracketing(String brackets) {\n    int depth = 0;\n    for (char b : brackets.toCharArray()) {\n        if (b == '(') {\n            depth += 1;\n        } else {\n            depth -= 1;\n        }\n        if (depth < 0) {\n            return false;\n        }\n    }\n    return depth == 0;\n}", "pred": "public func correctBracketing(brackets: String): Bool {\n    var depth = 0\n    for (b in brackets.toRuneArray()) {\n        if (b == '(') {\n            depth += 1\n        } else {\n            depth -= 1\n        }\n        if (depth < 0) {\n            return false\n        }\n    }\n    return depth == 0\n}\n"}
{"src": "/**\n * xs represent coefficients of a polynomial. xs[0] + xs[1] * x + xs[2] * x^2 + .... Return derivative of this polynomial in the same form.\n *\n * @param xs The list of coefficients of the polynomial.\n * @return The derivative of the polynomial in the same form.\n */\npublic List<Integer> derivative(List<Integer> xs) {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < xs.size(); i++) {\n        result.add(i * xs.get(i));\n    }\n    return result;\n}", "pred": "public func derivative(xs: ArrayList<Int64>): ArrayList<Int64> {\n    let result = ArrayList<Int64>()\n    for (i in 1..xs.size) {\n        result.append(i * xs[i])\n    }\n    return result\n}\n"}
{"src": "/**\n * The FibFib number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n * fibfib(0) == 0\n * fibfib(1) == 0\n * fibfib(2) == 1\n * fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n * Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n *\n * @param n The index of the Fibonacci number to compute.\n * @return The n-th Fibonacci number in the FibFib sequence.\n */\npublic int fibfib(int n) {\n    if (n == 0) {\n        return 0;\n    }\n    if (n == 1) {\n        return 0;\n    }\n    if (n == 2) {\n        return 1;\n    }\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}", "pred": "func fibfib(n: Int64): Int64 {\n    if (n == 0) {\n        return 0\n    }\n    if (n == 1) {\n        return 0\n    }\n    if (n == 2) {\n        return 1\n    }\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n}\n"}
{"src": "/**\n * Write a function vowelsCount which takes a string representing a word as input\n * and returns the number of vowels in the string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'.\n * Here, 'y' is also a vowel, but only when it is at the end of the given word.\n *\n * @param s The input string.\n * @return The number of vowels in the string.\n */\npublic int vowelsCount(String s) {\n    String vowels = \"aeiouAEIOU\";\n    int n_vowels = 0;\n    for (char c : s.toCharArray()) {\n        if (vowels.indexOf(c) != -1) {\n            n_vowels += 1;\n        }\n    }\n    if (s.charAt(s.length() - 1) == 'y' || s.charAt(s.length() - 1) == 'Y') {\n        n_vowels += 1;\n    }\n    return n_vowels;\n}", "pred": "public func vowelsCount(s: String): Int64 {\n    let vowels = \"aeiouAEIOU\"\n    var n_vowels = 0\n    for (c in s.toRuneArray()) {\n        if (vowels.contains(String(c))) {\n            n_vowels += 1\n        }\n    }\n    if (s.toRuneArray().last == 'y' || s.toRuneArray().last == 'Y') {\n        n_vowels += 1\n    }\n    return n_vowels\n}\n"}
{"src": "/**\n * Circular shift the digits of the integer x, shift the digits right by shift\n * and return the result as a string. If shift > number of digits, return digits reversed.\n *\n * @param x The input integer.\n * @param shift The number of positions to shift the digits.\n * @return The circular shifted digits as a string.\n */\npublic String circularShift(int x, int shift) {\n    String s = String.valueOf(x);\n    if (shift > s.length()) {\n        return new StringBuilder(s).reverse().toString();\n    } else {\n        return s.substring(s.length() - shift) + s.substring(0, s.length() - shift);\n    }\n}", "pred": "public func circularShift(x: Int64, shift: Int64): String {\n    let s = x.toString()\n    if (shift > s.size) {\n        return String(s.toRuneArray().reversed())\n    } else {\n        return s[s.size - shift..] + s[0..s.size - shift]\n    }\n}\n"}
{"src": "/**\n * Write a function that takes a string as input and returns the sum of the ASCII codes\n * of the uppercase characters in the string.\n *\n * @param s The input string.\n * @return The sum of ASCII codes of uppercase characters.\n */\npublic int digitSum(String s) {\n    int sum = 0;\n    for (char c : s.toCharArray()) {\n        if (Character.isUpperCase(c)) {\n            sum += c;\n        }\n    }\n    return sum;\n}", "pred": "func digitSum(s: String): Int64 {\n    var sum = 0\n    for (c in s.toRuneArray()) {\n        if (UInt32(c) >= UInt32('A') && UInt32(c) <= UInt32('Z')) {\n            sum += Int64(UInt32(c))\n        }\n    }\n    return sum\n}\n"}
{"src": "/**\n * Given a string representing the total number of oranges and apples in a basket,\n * and an integer representing the total number of fruits in the basket, this function\n * returns the number of mango fruits in the basket.\n *\n * @param s The string representing the number of oranges and apples.\n * @param n The total number of fruits in the basket.\n * @return The number of mango fruits in the basket.\n */\npublic int fruitDistribution(String s, int n) {\n    List<Integer> lis = new ArrayList<>();\n    for (String i : s.split(\" \")) {\n        try {\n            lis.add(Integer.parseInt(i));\n        } catch (NumberFormatException ignored) {\n\n        }\n    }\n    return n - lis.stream().mapToInt(Integer::intValue).sum();\n}", "pred": "public func fruitDistribution(s: String, n: Int64): Int64 {\n    let lis = ArrayList<Int64>()\n    for (i in s.split(\" \")) {\n        try {\n            lis.append(Int64.parse(i))\n        } catch (ignored: Exception) {\n\n        }\n    }\n    return n - lis.sum()\n}\n"}
{"src": "/**\n * Given an array representing a branch of a tree that has non-negative integer nodes,\n * this function plucks one of the nodes and returns it. The plucked node should be\n * the node with the smallest even value. If multiple nodes with the same smallest\n * even value are found, it returns the node with the smallest index. The plucked\n * node is returned in a list [smallest_value, its_index]. If there are no even\n * values or the given array is empty, it returns an empty list.\n *\n * @param arr The array representing the branch of the tree.\n * @return The plucked node in a list [smallest_value, its_index].\n */\npublic List<Integer> pluck(List<Integer> arr) {\n    List<Integer> result = new ArrayList<>();\n    if (arr.size() == 0) {\n        return result;\n    }\n    int min = Integer.MAX_VALUE;\n    int minIndex = -1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr.get(i) % 2 == 0) {\n            if (arr.get(i) < min) {\n                min = arr.get(i);\n                minIndex = i;\n            }\n        }\n    }\n    if (minIndex != -1) {\n        result.add(min);\n        result.add(minIndex);\n    }\n    return result;\n}", "pred": "public func pluck(arr: ArrayList<Int64>): ArrayList<Int64> {\n    var result: ArrayList<Int64> = ArrayList<Int64>()\n    if (arr.size == 0) {\n        return result\n    }\n    var min: Int64 = Int64.Max\n    var minIndex: Int64 = -1\n    for (i in 0..arr.size) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < min) {\n                min = arr[i]\n                minIndex = i\n            }\n        }\n    }\n    if (minIndex!= -1) {\n        result.append(min)\n        result.append(minIndex)\n    }\n    return result\n}\n"}
{"src": "/**\n * You are given a non-empty list of positive integers. This function returns\n * the greatest integer that is greater than zero, and has a frequency greater\n * than or equal to the value of the integer itself. The frequency of an integer\n * is the number of times it appears in the list. If no such value exists,\n * it returns -1.\n *\n * @param lst The list of positive integers.\n * @return The greatest integer that satisfies the conditions, or -1 if none exists.\n */\npublic int search(List<Integer> lst) {\n    int[] frq = new int[Collections.max(lst) + 1];\n    for (int i : lst) {\n        frq[i] += 1;\n    }\n    int ans = -1;\n    for (int i = 1; i < frq.length; i++) {\n        if (frq[i] >= i) {\n            ans = i;\n        }\n    }\n    return ans;\n}", "pred": "public func search(lst: ArrayList<Int64>): Int64 {\n    var frq = Array<Int64>(Int64(math.max(lst)) + 1, item: 0)\n    for (i in lst) {\n        frq[i] += 1\n    }\n    var ans = -1\n    for (i in 1..frq.size) {\n        if (frq[i] >= i) {\n            ans = i\n        }\n    }\n    return ans\n}\n"}
{"src": "/**\n * Given a list of integers, this function returns a list sorted in a strange order.\n * Strange sorting starts with the minimum value, then the maximum of the remaining integers,\n * then the minimum, and so on.\n *\n * @param lst The list of integers.\n * @return The list sorted in a strange order.\n */\npublic List<Integer> strangeSortList(List<Integer> lst) {\n    List<Integer> res = new ArrayList<>();\n    boolean _switch = true;\n    List<Integer> l = new ArrayList<>(lst);\n    while (l.size() != 0) {\n        if (_switch) {\n            res.add(Collections.min(l));\n        } else {\n            res.add(Collections.max(l));\n        }\n        l.remove(res.get(res.size() - 1));\n        _switch = !_switch;\n    }\n    return res;\n}", "pred": "public func strangeSortList(lst: ArrayList<Int64>): ArrayList<Int64> {\n    var res: ArrayList<Int64> = ArrayList<Int64>()\n    var _switch: Bool = true\n    var l: ArrayList<Int64> = ArrayList<Int64>(lst)\n    while (l.size!= 0) {\n        if (_switch) {\n            res.append(l.min().getOrThrow())\n        } else {\n            res.append(l.max().getOrThrow())\n        }\n        l.remove(res.get(res.size - 1).getOrThrow())\n        _switch =!_switch\n    }\n    return res\n}\n"}
{"src": "/**\n * Given the lengths of the three sides of a triangle, this function calculates the area of the triangle\n * rounded to 2 decimal points if the three sides form a valid triangle. Otherwise, it returns -1.\n *\n * @param a The length of the first side.\n * @param b The length of the second side.\n * @param c The length of the third side.\n * @return The area of the triangle if it's valid, otherwise -1.\n */\npublic double triangleArea(double a, double b, double c) {\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n    double s = (a + b + c) / 2;\n    double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n    area = (double) Math.round(area * 100) / 100;\n    return area;\n}", "pred": "public func triangleArea(a: Float64, b: Float64, c: Float64): Float64 {\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1.0\n    }\n    let s = (a + b + c) / 2.0\n    let area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return (math.round(area * 100.0)) / 100.0\n}\n"}
{"src": "/**\n * This function determines if an object will fly based on its balance and weight.\n * The object will fly if it's balanced (a palindromic list) and the sum of its elements\n * is less than or equal to the maximum possible weight.\n *\n * @param q The list representing the object.\n * @param w The maximum possible weight.\n * @return True if the object will fly, False otherwise.\n */\npublic boolean willItFly(List<Integer> q, int w) {\n    if (q.stream().reduce(0, Integer::sum) > w) {\n        return false;\n    }\n    int i = 0, j = q.size() - 1;\n    while (i < j) {\n        if (!Objects.equals(q.get(i), q.get(j))) {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    return true;\n}", "pred": "public func willItFly(q: ArrayList<Int64>, w: Int64): Bool {\n    if (q.sum() > w) {\n        return false\n    }\n    var i = 0\n    var j = q.size - 1\n    while (i < j) {\n        if (q[i]!= q[j]) {\n            return false\n        }\n        i += 1\n        j -= 1\n    }\n    return true\n}\n"}
{"src": "/**\n * This function finds the minimum number of elements that need to be changed to make the array palindromic.\n * A palindromic array is an array that is read the same backwards and forwards.\n * In one change, you can change one element to any other element.\n *\n * @param arr The input array of integers.\n * @return The minimum number of elements that need to be changed to make the array palindromic.\n */\npublic int smallestChange(List<Integer> arr) {\n    int ans = 0;\n    for (int i = 0; i < arr.size() / 2; i++) {\n        if (!Objects.equals(arr.get(i), arr.get(arr.size() - i - 1))) {\n            ans += 1;\n        }\n    }\n    return ans;\n}", "pred": "func smallestChange(arr: ArrayList<Int64>): Int64 {\n    var ans: Int64 = 0\n    for (i in 0..(arr.size / 2)) {\n        if (arr[i]!= arr[arr.size - i - 1]) {\n            ans += 1\n        }\n    }\n    return ans\n}\n"}
{"src": "/**\n * Write a function that accepts two lists of strings and returns the list\n * that has a total number of characters in all strings of the list less than the other list.\n * If the two lists have the same number of characters, return the first list.\n *\n * @param lst1 The first list of strings.\n * @param lst2 The second list of strings.\n * @return The list with a total number of characters less than the other list.\n */\npublic List<String> totalMatch(List<String> lst1, List<String> lst2) {\n    int l1 = 0;\n    for (String st : lst1) {\n        l1 += st.length();\n    }\n\n    int l2 = 0;\n    for (String st : lst2) {\n        l2 += st.length();\n    }\n\n    if (l1 <= l2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}", "pred": "public func totalMatch(lst1: ArrayList<String>, lst2: ArrayList<String>): ArrayList<String> {\n    var l1: Int64 = 0\n    for (st in lst1) {\n        l1 += Int64(st.size)\n    }\n\n    var l2: Int64 = 0\n    for (st in lst2) {\n        l2 += Int64(st.size)\n    }\n\n    if (l1 <= l2) {\n        return lst1\n    } else {\n        return lst2\n    }\n}\n"}
{"src": "/**\n * Write a function that returns true if the given number is the multiplication of 3 prime numbers and false otherwise.\n * Knowing that the number is less than 100.\n *\n * @param a The number to check.\n * @return True if the number is the multiplication of 3 prime numbers, false otherwise.\n */\npublic boolean isMultiplyPrime(int a) {\n    for (int i = 2; i < 101; i++) {\n        if (!IsPrime.is_prime(i)) {\n            continue;\n        }\n        for (int j = i; j < 101; j++) {\n            if (!IsPrime.is_prime(j)) {\n                continue;\n            }\n            for (int k = j; k < 101; k++) {\n                if (!IsPrime.is_prime(k)) {\n                    continue;\n                }\n                if (i * j * k == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}", "pred": "func isMultiplyPrime(a: Int64): Bool {\n    for (i in 2..101) {\n        if (!isPrime(i)) {\n            continue\n        }\n        for (j in i..101) {\n            if (!isPrime(j)) {\n                continue\n            }\n            for (k in j..101) {\n                if (!isPrime(k)) {\n                    continue\n                }\n                if (i * j * k == a) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n"}
{"src": "/**\n * Your task is to write a function that returns true if a number x is a simple power of n and false otherwise.\n * x is a simple power of n if n^int = x.\n *\n * @param x The number to check.\n * @param n The base.\n * @return True if x is a simple power of n, false otherwise.\n */\npublic boolean isSimplePower(int x, int n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    int power = 1;\n    while (power < x) {\n        power = power * n;\n    }\n    return power == x;\n}", "pred": "func isSimplePower(x: Int64, n: Int64): Bool {\n    if (n == 1) {\n        return x == 1\n    }\n    var power = 1\n    while (power < x) {\n        power = power * n\n    }\n    return power == x\n}\n"}
{"src": "/**\n * Write a function that takes an integer a and returns true if this integer is a cube of some integer number.\n *\n * @param a The integer to check.\n * @return True if a is a cube of some integer number, false otherwise.\n */\npublic boolean iscube(int a) {\n    a = Math.abs(a);\n    return Math.round(Math.pow(Math.round(Math.pow(a, 1. / 3)), 3)) == a;\n}", "pred": "func isCube(a: Int64): Bool {\n    let aAbs = math.abs(a)\n    return math.round(math.pow(math.round(math.pow(aAbs, 1.0 / 3.0)), 3.0)) == aAbs\n}\n"}
{"src": "/**\n * You have been tasked to write a function that receives a hexadecimal number as a string\n * and counts the number of hexadecimal digits that are primes.\n * Prime numbers in hexadecimal are: 2, 3, 5, 7, B, D.\n *\n * @param num The hexadecimal number as a string.\n * @return The number of hexadecimal digits that are primes.\n */\npublic int hexKey(String num) {\n    String primes = \"2357BD\";\n    int total = 0;\n    for (char c : num.toCharArray()) {\n        if (primes.indexOf(c) != -1) {\n            total += 1;\n        }\n    }\n    return total;\n}", "pred": "func hexKey(num: String): Int64 {\n    let primes = \"2357BD\"\n    var total = 0\n    for (c in num.toRuneArray()) {\n        if (primes.contains(String(c))) {\n            total += 1\n        }\n    }\n    return total\n}\n"}
{"src": "/**\n * Convert a decimal number to binary format.\n *\n * @param decimal The decimal number to convert.\n * @return The binary representation of the decimal number.\n */\npublic String decimalToBinary(int decimal) {\n    return \"db\" + Integer.toBinaryString(decimal) + \"db\";\n}", "pred": "public func decimalToBinary(decimal: Int64): String {\n    return \"db\" + decimal.toString(2) + \"db\"\n}"}
{"src": "/**\n* Checks if a string is happy.\n* \n* @param s The input string.\n* @return true if the string is happy, false otherwise.\n*/\npublic boolean isHappy(String s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    for (int i = 0; i < s.length() - 2; i++) {\n        if (s.charAt(i) == s.charAt(i + 1) || s.charAt(i + 1) == s.charAt(i + 2) || s.charAt(i) == s.charAt(i + 2)) {\n            return false;\n        }\n    }\n    return true;\n}", "pred": "func isHappy(s: String): Bool {\n    if (s.size < 3) {\n        return false\n    }\n\n    for (i in 0..s.size - 2) {\n        if (s[i] == s[i + 1] || s[i + 1] == s[i + 2] || s[i] == s[i + 2]) {\n            return false\n        }\n    }\n    return true\n}\n"}
{"src": "/**\n* Converts a list of GPAs to letter grades.\n* \n* @param grades The list of GPAs.\n* @return The list of corresponding letter grades.\n*/\npublic List<String> numericalLetterGrade(List<Double> grades) {\n    List<String> letter_grade = new ArrayList<>();\n    for (double gpa : grades) {\n        if (gpa == 4.0) {\n            letter_grade.add(\"A+\");\n        } else if (gpa > 3.7) {\n            letter_grade.add(\"A\");\n        } else if (gpa > 3.3) {\n            letter_grade.add(\"A-\");\n        } else if (gpa > 3.0) {\n            letter_grade.add(\"B+\");\n        } else if (gpa > 2.7) {\n            letter_grade.add(\"B\");\n        } else if (gpa > 2.3) {\n            letter_grade.add(\"B-\");\n        } else if (gpa > 2.0) {\n            letter_grade.add(\"C+\");\n        } else if (gpa > 1.7) {\n            letter_grade.add(\"C\");\n        } else if (gpa > 1.3) {\n            letter_grade.add(\"C-\");\n        } else if (gpa > 1.0) {\n            letter_grade.add(\"D+\");\n        } else if (gpa > 0.7) {\n            letter_grade.add(\"D\");\n        } else if (gpa > 0.0) {\n            letter_grade.add(\"D-\");\n        } else {\n            letter_grade.add(\"E\");\n        }\n    }\n    return letter_grade;\n}", "pred": "public func numericalLetterGrade(grades: ArrayList<Float64>): ArrayList<String> {\n    var letter_grade: ArrayList<String> = ArrayList<String>()\n    for (gpa in grades) {\n        if (gpa == 4.0) {\n            letter_grade.append(\"A+\")\n        } else if (gpa > 3.7) {\n            letter_grade.append(\"A\")\n        } else if (gpa > 3.3) {\n            letter_grade.append(\"A-\")\n        } else if (gpa > 3.0) {\n            letter_grade.append(\"B+\")\n        } else if (gpa > 2.7) {\n            letter_grade.append(\"B\")\n        } else if (gpa > 2.3) {\n            letter_grade.append(\"B-\")\n        } else if (gpa > 2.0) {\n            letter_grade.append(\"C+\")\n        } else if (gpa > 1.7) {\n            letter_grade.append(\"C\")\n        } else if (gpa > 1.3) {\n            letter_grade.append(\"C-\")\n        } else if (gpa > 1.0) {\n            letter_grade.append(\"D+\")\n        } else if (gpa > 0.7) {\n            letter_grade.append(\"D\")\n        } else if (gpa > 0.0) {\n            letter_grade.append(\"D-\")\n        } else {\n            letter_grade.append(\"E\")\n        }\n    }\n    return letter_grade\n}"}
{"src": "/**\n* Checks if the length of a string is a prime number.\n* \n* @param string The input string.\n* @return true if the length is a prime number, false otherwise.\n*/\npublic boolean primeLength(String string) {\n    int l = string.length();\n    if (l == 0 || l == 1) {\n        return false;\n    }\n    for (int i = 2; i < l; i++) {\n        if (l % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}", "pred": "public func primeLength(string: String): Bool {\n    let l = string.size\n    if (l == 0 || l == 1) {\n        return false\n    }\n    for (i in 2..l) {\n        if (l % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n"}
{"src": "/**\n * Given a positive integer n, returns the count of n-digit positive integers\n * that start or end with 1.\n * \n * @param n The number of digits for the integers.\n * @return The count of n-digit positive integers starting or ending with 1.\n */\npublic int startsOneEnds(int n) {\n    if (n == 1) {\n        return 1;\n    }\n    return 18 * (int) Math.pow(10, n - 2);\n}", "pred": "func startsOneEnds(n: Int64): Int64 {\n    if (n == 1) {\n        return 1\n    }\n    18 * pow(10, n - 2)\n}\n"}
{"src": "/**\n * Given a positive integer N, calculates the sum of its digits in binary representation.\n * \n * @param N The positive integer.\n * @return A string representing the sum of digits in binary.\n */\n\npublic String solve(int N) {\n    int sum = 0;\n    for (char c : String.valueOf(N).toCharArray()) {\n        sum += (c - '0');\n    }\n    return Integer.toBinaryString(sum);\n}", "pred": "func solve(N: Int64): String {\n    var sum = 0\n    for (c in N.toString()) {\n        sum += Int64(UInt32(c) - UInt32('0'))\n    }\n    return sum.toString(2)\n}\n"}
{"src": "/**\n * Given a non-empty list of integers, adds the even elements that are at odd indices.\n * \n * @param lst The non-empty list of integers.\n * @return The sum of even elements at odd indices.\n */\n\npublic int add(List<Integer> lst) {\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst.get(i) % 2 == 0) {\n            sum += lst.get(i);\n        }\n    }\n    return sum;\n}", "pred": "public func add(lst: ArrayList<Int64>): Int64 {\n    var sum: Int64 = 0\n    for (i in 1..lst.size : 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i]\n        }\n    }\n    return sum\n}\n"}
{"src": "/**\n * Write a function that takes a string and returns an ordered version of it.\n * \n * @param s The input string.\n * @return The ordered version of the input string.\n */\n\npublic String antiShuffle(String s) {\n    String[] strings = s.split(\" \");\n    List<String> result = new ArrayList<>();\n    for (String string : strings) {\n        char[] chars = string.toCharArray();\n        Arrays.sort(chars);\n        result.add(String.copyValueOf(chars));\n    }\n    return String.join(\" \", result);\n}", "pred": "public func antiShuffle(s: String): String {\n    let strings = s.split(\" \")\n    let result = ArrayList<String>()\n    for (string in strings) {\n        let chars = string.toRuneArray()\n        chars.sort()\n        result.append(String(chars))\n    }\n    return result.joinToString(\" \")\n}\n"}
{"src": "/**\n * Given a 2-dimensional data represented as nested lists, where each row may contain a different\n * number of columns, find the integer x in the list and return a list of lists representing\n * coordinates [[x1, y1], [x2, y2], ...] such that each list is a coordinate - (row, columns),\n * starting with 0. Coordinates are sorted initially by rows in ascending order and by columns in\n * descending order.\n * \n * @param lst The 2-dimensional data represented as nested lists.\n * @param x The integer to find in the list.\n * @return A list of lists representing coordinates.\n */\n\npublic List<List<Integer>> getRow(List<List<Integer>> lst, int x) {\n    List<List<Integer>> coords = new ArrayList<>();\n    for (int i = 0; i < lst.size(); i++) {\n        List<List<Integer>> row = new ArrayList<>();\n        for (int j = lst.get(i).size() - 1; j >= 0; j--) {\n            if (lst.get(i).get(j) == x) {\n                row.add(Arrays.asList(i, j));\n            }\n        }\n        coords.addAll(row);\n    }\n    return coords;\n}", "pred": "public func getRow(lst: ArrayList<ArrayList<Int64>>, x: Int64): ArrayList<ArrayList<Int64>> {\n    let coords = ArrayList<ArrayList<Int64>>()\n    for (i in 0..lst.size) {\n        let row = ArrayList<ArrayList<Int64>>()\n        for (j in (lst.get(i).size - 1)..-1) {\n            if (lst.get(i).get(j) == x) {\n                row.append(ArrayList<Int64>([i, j]))\n            }\n        }\n        coords.appendAll(row)\n    }\n    return coords\n}\n"}
{"src": "/**\n * Given an array of non-negative integers, return a copy of the given array after sorting.\n * \n * @param array The list of non-negative integers to be sorted.\n * @return A sorted copy of the input array. If the sum of the first and last elements of the array is odd,\n *         the array is sorted in ascending order. If the sum is even, the array is sorted in descending order.\n */\n\npublic List<Integer> sortArray(List<Integer> array) {\n    if (array.size() == 0) {\n        return array;\n    }\n    List<Integer> result = new ArrayList<>(array);\n    if ((result.get(0) + result.get(result.size() - 1)) % 2 == 1) {\n        Collections.sort(result);\n    } else {\n        result.sort(Collections.reverseOrder());\n    }\n    return result;\n}", "pred": "public func sortArray(array: ArrayList<Int64>): ArrayList<Int64> {\n    if (array.size == 0) {\n        return array\n    }\n    var result = array\n    if ((result[0] + result[result.size - 1]) % 2 == 1) {\n        result.sortBy({ a: Int64, b: Int64 =>\n            if (a < b) {\n                return Ordering.LT\n            }\n            if (a > b) {\n                return Ordering.GT\n            }\n            return Ordering.EQ\n        })\n    } else {\n        result.sortBy({ a: Int64, b: Int64 =>\n            if (a < b) {\n                return Ordering.GT\n            }\n            if (a > b) {\n                return Ordering.LT\n            }\n            return Ordering.EQ\n        })\n    }\n    return result\n}\n"}
{"src": "/**\n * Create a function encrypt that takes a string as an argument and returns a string encrypted with the alphabet being rotated.\n * The alphabet should be rotated in a manner such that the letters shift down by two multiplied to two places.\n * \n * @param s The string to be encrypted.\n * @return The encrypted string.\n */\n\npublic String encrypt(String s) {\n    StringBuilder sb = new StringBuilder();\n    for (char c : s.toCharArray()) {\n        if (Character.isLetter(c)) {\n            sb.append((char) ('a' + (c - 'a' + 2 * 2) % 26));\n        } else {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}", "pred": "public func encrypt(s: String): String {\n    let sb = StringBuilder()\n    for (c in s.toRuneArray()) {\n        if (c >= 'a' && c <= 'z') {\n            sb.append(Char(UInt32('a') + (UInt32(c) - UInt32('a') + 2 * 2) % 26))\n        } else {\n            sb.append(c)\n        }\n    }\n    return sb.toString()\n}\n"}
{"src": "/**\n * You are given a list of integers. Write a function nextSmallest() that returns the 2nd smallest element of the list.\n * Return null if there is no such element.\n * \n * @param lst The list of integers from which to find the 2nd smallest element.\n * @return An Optional containing the 2nd smallest element if found, or empty if no such element exists.\n */\n\npublic Optional<Integer> nextSmallest(List<Integer> lst) {\n            Set < Integer > set = new HashSet<>(lst);\n    List<Integer> l = new ArrayList<>(set);\n    Collections.sort(l);\n    if (l.size() < 2) {\n        return Optional.empty();\n    } else {\n        return Optional.of(l.get(1));\n    }\n}", "pred": "public func nextSmallest(lst: ArrayList<Int64>): Option<Int64> {\n    let set = HashSet<Int64>(lst)\n    let l = ArrayList<Int64>(set)\n    l.sortBy({a: Int64, b: Int64 =>\n        if (a < b) {\n            return Ordering.LT\n        }\n        if (a > b) {\n            return Ordering.GT\n        }\n        return Ordering.EQ\n    })\n    if (l.size < 2) {\n        return Option<Int64>.None\n    } else {\n        return Option<Int64>.Some(l[1])\n    }\n}\n"}
{"src": "/**\n * You'll be given a string of words, and your task is to count the number of \"boredoms\".\n * A \"boredom\" is a sentence that starts with the word \"I\". Sentences are delimited by '.', '?' or '!'.\n * \n * @param S The string of words to analyze for \"boredoms\".\n * @return The count of sentences (boredoms) that start with the word \"I\".\n */\n\npublic int isBored(String S) {\n    String [] sentences = S.split(\"[.?!]\\s*\");\n    int count = 0;\n    for (String sentence : sentences) {\n        if (sentence.subSequence(0, 2).equals(\"I \")) {\n            count += 1;\n        }\n    }\n    return count;\n}", "pred": "func isBored(S: String): Int64 {\n    let sentences = S.split(separator: \"[.?!]\\s*\")\n    var count = 0\n    for (sentence in sentences) {\n        if (sentence.substring(0, 2) == \"I \") {\n            count += 1\n        }\n    }\n    return count\n}\n"}
{"src": "/**\n * Create a function that takes 3 numbers. Returns true if one of the numbers is equal to the sum of the other two,\n * and all numbers are integers. Returns false in any other cases.\n * \n * @param x The first number.\n * @param y The second number.\n * @param z The third number.\n * @return true if one number is equal to the sum of the other two and all numbers are integers, false otherwise.\n */\n\npublic boolean anyInt(Object x, Object y, Object z) {\n    if (x instanceof Integer && y instanceof Integer && z instanceof Integer) {\n        return (int) x + (int) y == (int) z || (int) x + (int) z == (int) y || (int) y + (int) z == (int) x;\n    }\n    return false;\n}", "pred": "public func anyInt(x: Any, y: Any, z: Any): Bool {\n    if (let (xi, yi, zi) = (x as Int64, y as Int64, z as Int64)) {\n        return xi + yi == zi || xi + zi == yi || yi + zi == xi\n    }\n    return false\n}\n"}
{"src": "/**\n * Write a function that takes a message and encodes it in a specific manner:\n * - Swaps the case of all letters.\n * - Replaces all vowels in the message with the letter that appears 2 places ahead of that vowel in the English alphabet.\n * \n * @param message The message to be encoded.\n * @return The encoded message with swapped case and replaced vowels.\n */\n\npublic String encode(String message) {\n    String vowels = \"aeiouAEIOU\";\n    StringBuilder sb = new StringBuilder();\n    for (char c : message.toCharArray()) {\n        char ch = c;\n        if (Character.isUpperCase(ch)) {\n            ch = Character.toLowerCase(ch);\n            if (vowels.indexOf(ch) != -1) {\n                ch = (char) ('a' + ((ch - 'a' + 28) % 26));\n            }\n        } else if (Character.isLowerCase(ch)) {\n            ch = Character.toUpperCase(ch);\n            if (vowels.indexOf(ch) != -1) {\n                ch = (char) ('A' + ((ch - 'A' + 28) % 26));\n            }\n        }\n        sb.append(ch);\n    }\n    return sb.toString();\n}", "pred": "public func encode(message: String): String {\n    let vowels = \"aeiouAEIOU\"\n    let sb = StringBuilder()\n    for (c in message.toAsciiLower().toRuneArray()) {\n        var ch = c\n        if (UInt32(ch) >= UInt32('a') && UInt32(ch) <= UInt32('z')) {\n            ch = UInt32(UInt32('a') + ((UInt32(ch) - UInt32('a') + 28) % 26))\n        } else if (UInt32(ch) >= UInt32('A') && UInt32(ch) <= UInt32('Z')) {\n            ch = UInt32(UInt32('A') + ((UInt32(ch) - UInt32('A') + 28) % 26))\n        }\n        sb.append(Char(ch))\n    }\n    return sb.toString()\n}\n"}
{"src": "/**\n * You are given a list of integers. Find the largest prime value in the list and return the sum of its digits.\n * \n * @param lst The list of integers.\n * @return The sum of the digits of the largest prime value in the list.\n */\n\npublic int skjkasdkd(List<Integer> lst) {\n    int maxx = 0;\n    for (int i : lst) {\n        if (i > maxx) {\n            boolean isPrime = i != 1;\n            for (int j = 2; j < Math.sqrt(i) + 1; j++) {\n                if (i % j == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n            if (isPrime) {\n                maxx = i;\n            }\n        }\n    }\n    int sum = 0;\n    for (char c : String.valueOf(maxx).toCharArray()) {\n        sum += (c - '0');\n    }\n    return sum;\n}", "pred": "func skjkasdkd(lst: ArrayList<Int64>): Int64 {\n    var maxx = 0\n    for (i in lst) {\n        if (i > maxx) {\n            var isPrime = i!= 1\n            for (j in 2..Int64(math.sqrt(Float64(i)))) {\n                if (i % j == 0) {\n                    isPrime = false\n                    break\n                }\n            }\n            if (isPrime) {\n                maxx = i\n            }\n        }\n    }\n    var sum = 0\n    for (c in maxx.toString()) {\n        sum += Int64(UInt32(c) - UInt32('0'))\n    }\n    return sum\n}\n"}
{"src": "/**\n * Given a map, return true if all keys are strings in lowercase or all keys are strings in uppercase,\n * otherwise return false. Returns false if the given map is empty.\n * \n * @param dict The map to be checked.\n * @return true if all keys are strings in consistent case (either all lowercase or all uppercase), false otherwise.\n */\n\npublic boolean checkDictCase(Map<Object, Object> dict) {\n    if (dict.isEmpty()) {\n        return false;\n    }\n    String state = \"start\";\n    for (Map.Entry entry : dict.entrySet()) {\n        if (!(entry.getKey() instanceof String key)) {\n            state = \"mixed\";\n            break;\n        }\n        boolean is_upper = true, is_lower = true;\n        for (char c : key.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                is_upper = false;\n            } else if (Character.isUpperCase(c)) {\n                is_lower = false;\n            } else {\n                is_upper = false;\n                is_lower = false;\n            }\n        }\n        if (state.equals(\"start\")) {\n            if (is_upper) {\n                state = \"upper\";\n            } else if (is_lower) {\n                state = \"lower\";\n            } else {\n                break;\n            }\n        } else if ((state.equals(\"upper\") && !is_upper) || (state.equals(\"lower\") && !is_lower)) {\n            state = \"mixed\";\n            break;\n        }\n    }\n    return state.equals(\"upper\") || state.equals(\"lower\");\n}", "pred": "public func checkDictCase(dict: HashMap<String, Any>): Bool {\n    if (dict.isEmpty()) {\n        return false\n    }\n    var state = \"start\"\n    for ((key, value) in dict) {\n        if (!(key is String)) {\n            state = \"mixed\"\n            break\n        }\n        var is_upper = true\n        var is_lower = true\n        for (c in key.toRuneArray()) {\n            if (UInt32(c) >= UInt32('A') && UInt32(c) <= UInt32('Z')) {\n                is_upper = false\n            } else if (UInt32(c) >= UInt32('a') && UInt32(c) <= UInt32('z')) {\n                is_lower = false\n            } else {\n                is_upper = false\n                is_lower = false\n            }\n        }\n        if (state == \"start\") {\n            if (is_upper) {\n                state = \"upper\"\n            } else if (is_lower) {\n                state = \"lower\"\n            } else {\n                break\n            }\n        } else if ((state == \"upper\" &&!is_upper) || (state == \"lower\" &&!is_lower)) {\n            state = \"mixed\"\n            break\n        }\n    }\n    return state == \"upper\" || state == \"lower\"\n}\n"}
{"src": "/**\n * Implement a function that takes a non-negative integer and returns an array of the first n prime numbers\n * that are less than n.\n * \n * @param n The upper limit (exclusive) for finding prime numbers.\n * @return A list of the first n prime numbers less than n.\n */\n\npublic List<Integer> countUpTo(int n) {\n    List<Integer> primes = new ArrayList<>();\n    for (int i = 2; i < n; i++) {\n        boolean is_prime = true;\n        for (int j = 2; j < i; j++) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.add(i);\n        }\n    }\n    return primes;\n}", "pred": "public func countUpTo(n: Int64): ArrayList<Int64> {\n    let primes = ArrayList<Int64>()\n    for (i in 2..n) {\n        var is_prime = true\n        for (j in 2..i) {\n            if (i % j == 0) {\n                is_prime = false\n                break\n            }\n        }\n        if (is_prime) {\n            primes.append(i)\n        }\n    }\n    return primes\n}\n"}
{"src": "/**\n * Complete the function that takes two integers and returns the product of their unit digits.\n * \n * @param a The first integer.\n * @param b The second integer.\n * @return The product of the unit digits of the two integers.\n */\n\npublic int multiply(int a, int b) {\n    return Math.abs(a % 10) * Math.abs(b % 10);\n}", "pred": "func multiply(a: Int64, b: Int64): Int64 {\n    return math.abs(a % 10) * math.abs(b % 10)\n}\n"}
{"src": "/**\n * Given a string s, count the number of uppercase vowels in even indices.\n * \n * @param s The input string.\n * @return The count of uppercase vowels in even indices of the string.\n */\n\npublic int countUpper(String s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (\"AEIOU\".indexOf(s.charAt(i)) != -1) {\n            count += 1;\n        }\n    }\n    return count;\n}", "pred": " func countUpper(s: String): Int64 {\n    var count = 0\n    for (i in 0..s.size : 2) {\n        if (\"AEIOU\".contains(s[i])) {\n            count += 1\n        }\n    }\n    return count\n}\n"}
{"src": "/**\n * Create a function that takes a value (string) representing a number and returns the closest integer to it.\n * If the number is equidistant from two integers, round it away from zero.\n * \n * @param value The string representing the number.\n * @return The closest integer to the specified number, rounded away from zero if equidistant.\n */\n\npublic int countUpper(String value) {\n    if (value.contains(\".\")) {\n        while (value.charAt(value.length() - 1) == '0') {\n            value = value.substring(0, value.length() - 1);\n        }\n    }\n    double num = Double.parseDouble(value);\n    int res = 0;\n    if (value.substring(Math.max(value.length() - 2, 0)).equals(\".5\")) {\n        if (num > 0) {\n            res = (int) Math.ceil(num);\n        } else {\n            res = (int) Math.floor(num);\n        }\n    } else if(value.length() > 0) {\n        res = (int) Math.round(num);\n    }\n    return res;\n}", "pred": "func countUpper(value: String): Int64 {\n    if (value.contains(\".\")) {\n        while (value.toRuneArray().last() == '0') {\n            value = value[..value.size - 1]\n        }\n    }\n    let num = Float64.parse(value)\n    var res = 0\n    if (value[Int64(math.max(value.size - 2, 0))..value.size] == \".5\") {\n        if (num > 0) {\n            res = Int64(math.ceil(num))\n        } else {\n            res = Int64(math.floor(num))\n        }\n    } else if(value.size > 0) {\n        res = Int64(math.round(num))\n    }\n    return res\n}\n"}
{"src": "/**\n * Given a positive integer n, create a pile of n levels of stones.\n * The number of stones in each level follows a specific pattern:\n * - If n is odd, the next level has the next odd number of stones.\n * - If n is even, the next level has the next even number of stones.\n * \n * @param n The number of levels of stones to create.\n * @return A list representing the number of stones in each level, where element at index i\n *         represents the number of stones in level (i+1).\n */\n\npublic List<Integer> makeAPile(int n) {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        result.add(n + 2 * i);\n    }\n    return result;\n}", "pred": "public func makeAPile(n: Int64): ArrayList<Int64> {\n    var result = ArrayList<Int64>()\n    for (i in 0..n) {\n        result.append(n + 2 * i)\n    }\n    return result\n}\n"}
{"src": "/**\n * You will be given a string of words separated by commas or spaces.\n * Split the string into words and return a list of the words.\n * \n * @param s The input string containing words separated by commas or spaces.\n * @return A list of words extracted from the input string.\n */\n\npublic List<String> wordStrings(String s) {\n    if (s.length() == 0) {\n        return List.of();\n    }\n    StringBuilder sb = new StringBuilder();\n\n    for (char letter : s.toCharArray()) {\n        if (letter == ',') {\n            sb.append(' ');\n        } else {\n            sb.append(letter);\n        }\n    }\n\n    return new ArrayList<>(Arrays.asList(sb.toString().split(\"\\s+\" )));\n}", "pred": "public func wordStrings(s: String): ArrayList<String> {\n    if (s.size == 0) {\n        return ArrayList<String>()\n    }\n    let sb = StringBuilder()\n\n    for (letter in s.toRuneArray()) {\n        if (letter == ',') {\n            sb.append(' ')\n        } else {\n            sb.append(letter)\n        }\n    }\n\n    return ArrayList<String>(sb.toString().split(\" \"))\n}\n"}
{"src": "/**\n * This function takes two positive numbers x and y and returns the\n * biggest even integer number that is in the range [x, y] inclusive.\n * If there's no such number, then the function should return -1.\n * \n * @param x The lower bound of the range.\n * @param y The upper bound of the range.\n * @return The largest even integer within the range [x, y], or -1 if no such number exists.\n */\n\npublic int chooseNum(int x, int y) {\n    if (x > y) {\n        return -1;\n    }\n    if (y % 2 == 0) {\n        return y;\n    }\n    if (x == y) {\n        return -1;\n    }\n    return y - 1;\n}", "pred": "func chooseNum(x: Int64, y: Int64): Int64 {\n    if (x > y) {\n        return -1\n    }\n    if (y % 2 == 0) {\n        return y\n    }\n    if (x == y) {\n        return -1\n    }\n    return y - 1\n}\n"}
{"src": "/**\n * You are given two positive integers n and m, and your task is to compute the average\n * of the integers from n through m (including n and m). Round the answer to the nearest integer\n * and convert that to binary. If n is greater than m, return -1.\n * \n * @param n The lower bound of the range.\n * @param m The upper bound of the range.\n * @return The rounded average of integers from n through m in binary form,\n *         or -1 if n is greater than m.\n */\n\npublic Object roundedAvg(int n, int m) {\n    if (n > m) {\n        return -1;\n    }\n    return Integer.toBinaryString((int) Math.round((double) (m + n) / 2));\n}", "pred": "public func roundedAvg(n: Int64, m: Int64): String {\n    if (n > m) {\n        return \"-1\"\n    }\n    return \"${Int64(math.round((Float64(m + n) / 2.0)))}\"\n}\n"}
{"src": "/**\n * Given a list of positive integers x, return a sorted list of all elements that do not contain any even digit.\n * \n * @param x The list of positive integers.\n * @return A sorted list of integers from the input list that do not contain any even digit.\n */\n\npublic List<Integer> uniqueDigits(List<Integer> x) {\n    List<Integer> odd_digit_elements = new ArrayList<>();\n    for (int i : x) {\n        boolean is_unique = true;\n        for (char c : String.valueOf(i).toCharArray()) {\n            if ((c - '0') % 2 == 0) {\n                is_unique = false;\n                break;\n            }\n        }\n        if (is_unique) {\n            odd_digit_elements.add(i);\n        }\n    }\n    Collections.sort(odd_digit_elements);\n    return odd_digit_elements;\n}", "pred": "public func uniqueDigits(x: ArrayList<Int64>): ArrayList<Int64> {\n    let odd_digit_elements = ArrayList<Int64>()\n    for (i in x) {\n        var is_unique = true\n        for (c in i.toString().toRuneArray()) {\n            if ((Int64(UInt32(c)) - Int64('0')) % 2 == 0) {\n                is_unique = false\n                break\n            }\n        }\n        if (is_unique) {\n            odd_digit_elements.append(i)\n        }\n    }\n    odd_digit_elements.sortBy({a: Int64, b: Int64 =>\n        if (a < b) {\n            return Ordering.LT\n        }\n        if (a > b) {\n            return Ordering.GT\n        }\n        return Ordering.EQ\n    })\n    return odd_digit_elements\n}\n"}
{"src": "/**\n * Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n * reverse the resulting array, and then replace each digit by its corresponding name\n * from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n * \n * @param arr The array of integers to process.\n * @return A list of strings representing the sorted and reversed integers replaced with their names,\n *         filtered to include only numbers between 1 and 9.\n */\n\npublic List<String> byLength(List<Integer> arr) {\n    List<Integer> sorted_arr = new ArrayList<>(arr);\n    sorted_arr.sort(Collections.reverseOrder());\n    List<String> new_arr = new ArrayList<>();\n    for (int var : sorted_arr) {\n        if (var >= 1 && var <= 9) {\n            switch (var) {\n                case 1 -> new_arr.add(\"One\");\n                case 2 -> new_arr.add(\"Two\");\n                case 3 -> new_arr.add(\"Three\");\n                case 4 -> new_arr.add(\"Four\");\n                case 5 -> new_arr.add(\"Five\");\n                case 6 -> new_arr.add(\"Six\");\n                case 7 -> new_arr.add(\"Seven\");\n                case 8 -> new_arr.add(\"Eight\");\n                case 9 -> new_arr.add(\"Nine\");\n            }\n        }\n    }\n    return new_arr;\n}", "pred": "public func byLength(arr: ArrayList<Int64>): ArrayList<String> {\n    let sorted_arr = arr.sorted(by: >)\n    let new_arr = ArrayList<String>()\n    for (var in sorted_arr) {\n        if (var >= 1 && var <= 9) {\n            match (var) {\n                case 1 => new_arr.append(\"One\")\n                case 2 => new_arr.append(\"Two\")\n                case 3 => new_arr.append(\"Three\")\n                case 4 => new_arr.append(\"Four\")\n                case 5 => new_arr.append(\"Five\")\n                case 6 => new_arr.append(\"Six\")\n                case 7 => new_arr.append(\"Seven\")\n                case 8 => new_arr.append(\"Eight\")\n                case 9 => new_arr.append(\"Nine\")\n                case _ => ()\n            }\n        }\n    }\n    return new_arr\n}\n"}
{"src": "/**\n * Implement the function f that takes n as a parameter and returns a list of size n.\n * The value of the element at index i is the factorial of i if i is even, or the sum of numbers from 1 to i otherwise.\n * \n * @param n The size of the list to generate.\n * @return A list where each element at index i is the factorial of i if i is even,\n *         or the sum of numbers from 1 to i if i is odd. i starts from 1.\n */\n\npublic List<Integer> f(int n) {\n    List<Integer> ret = new ArrayList<>();\n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            int x = 1;\n            for (int j = 1; j <= i; j++) {\n                x *= j;\n            }\n            ret.add(x);\n        } else {\n            int x = 0;\n            for (int j = 1; j <= i; j++) {\n                x += j;\n            }\n            ret.add(x);\n        }\n    }\n    return ret;\n}", "pred": "public func f(n: Int64): ArrayList<Int64> {\n    var ret: ArrayList<Int64> = ArrayList<Int64>()\n    for (i in 1..=n) {\n        if (i % 2 == 0) {\n            var x: Int64 = 1\n            for (j in 1..=i) {\n                x *= j\n            }\n            ret.append(x)\n        } else {\n            var x: Int64 = 0\n            for (j in 1..=i) {\n                x += j\n            }\n            ret.append(x)\n        }\n    }\n    return ret\n}\n"}
{"src": "/**\n * Given a positive integer n, return a tuple that contains the count of even and odd integer palindromes\n * that fall within the range [1, n], inclusive.\n * \n * @param n The upper limit of the range to check for palindromes.\n * @return A list containing two integers: the count of even integer palindromes and the count of odd integer palindromes.\n */\n\npublic List<Integer> evenOddPalindrome(int n) {\n    int even_palindrome_count = 0, odd_palindrome_count = 0;\n\n    for (int i = 1; i <= n; i++) {\n        if (String.valueOf(i).equals(new StringBuilder(String.valueOf(i)).reverse().toString())) {\n            if (i % 2 == 1) {\n                odd_palindrome_count += 1;\n            } else {\n                even_palindrome_count += 1;\n            }\n        }\n    }\n    return Arrays.asList(even_palindrome_count, odd_palindrome_count);\n}", "pred": "public func evenOddPalindrome(n: Int64): ArrayList<Int64> {\n    var even_palindrome_count: Int64 = 0\n    var odd_palindrome_count: Int64 = 0\n\n    for (i in 1..=n) {\n        if (i.toString() == i.toString().toRuneArray().reversed().toString()) {\n            if (i % 2 == 1) {\n                odd_palindrome_count += 1\n            } else {\n                even_palindrome_count += 1\n            }\n        }\n    }\n    return ArrayList<Int64>([even_palindrome_count, odd_palindrome_count])\n}\n"}
{"src": "/**\n * Write a function countNums which takes an array of integers and returns the number of elements\n * which have a sum of digits greater than 0. If a number is negative, then its first signed digit will be negative:\n * e.g., -123 has signed digits -1, 2, and 3.\n * \n * @param arr The list of integers to process.\n * @return The number of elements in the list whose sum of digits is greater than 0.\n */\n\npublic int countNums(List<Integer> arr) {\n    int count = 0;\n    for (int n: arr) {\n        int neg = 1;\n        if (n < 0) {\n            n = -n;\n            neg = -1;\n        }\n        List<Integer> digits = new ArrayList<>();\n        for (char digit : String.valueOf(n).toCharArray()) {\n            digits.add(digit - '0');\n        }\n        digits.set(0, digits.get(0) * neg);\n        if (digits.stream().reduce(0, Integer::sum) > 0) {\n            count += 1;\n        }\n    }\n    return count;\n}", "pred": "func countNums(arr: ArrayList<Int64>): Int64 {\n    var count = 0\n    for (n in arr) {\n        var neg = 1\n        if (n < 0) {\n            n = -n\n            neg = -1\n        }\n        var digits = ArrayList<Int64>()\n        for (digit in n.toString().toRuneArray()) {\n            digits.append(Int64(UInt32(digit) - UInt32('0')))\n        }\n        digits[0] = digits[0] * neg\n        if (digits.reduce(0, {x, y => x + y}) > 0) {\n            count += 1\n        }\n    }\n    return count\n}\n"}
{"src": "/**\n * Determine if it is possible to obtain a sorted array in non-decreasing order\n * by performing right shift operations on the given array.\n * \n * @param arr The array of integers to evaluate.\n * @return true if it is possible to obtain a sorted array by performing right shift operations,\n *         false otherwise.\n */\n\npublic boolean moveOneBall(List<Integer> arr) {\n    if (arr.size() == 0) {\n        return true;\n    }\n    List<Integer> sorted_arr = new ArrayList<>(arr);\n    Collections.sort(sorted_arr);\n\n    int min_value = Collections.min(arr);\n    int min_index = arr.indexOf(min_value);\n    List<Integer> my_arr = new ArrayList<>(arr.subList(min_index, arr.size()));\n    my_arr.addAll(arr.subList(0, min_index));\n    for (int i = 0; i < arr.size(); i++) {\n        if (my_arr.get(i) != sorted_arr.get(i)) {\n            return false;\n        }\n    }\n    return true;\n}", "pred": "func moveOneBall(arr: ArrayList<Int64>): Bool {\n    if (arr.size == 0) {\n        return true\n    }\n    let sorted_arr = arr.sorted()\n    let min_value = arr.min()?? 0\n    let min_index = arr.indexOf(min_value)?? 0\n    let my_arr = arr[min_index..] + arr[0..min_index]\n    for (i in 0..arr.size) {\n        if (my_arr[i]!= sorted_arr[i]) {\n            return false\n        }\n    }\n    return true\n}\n"}
{"src": "/**\n * Determine whether it is possible to perform an exchange of elements between two lists\n * to make the first list (lst1) contain only even numbers.\n * \n * @param lst1 The first list of numbers.\n * @param lst2 The second list of numbers.\n * @return \"YES\" if it is possible to exchange elements to make all elements of lst1 even,\n *         otherwise \"NO\".\n */\n\npublic String exchange(List<Integer> lst1, List<Integer> lst2) {\n    int odd = 0, even = 0;\n    for (int i : lst1) {\n        if (i % 2 == 1) {\n            odd += 1;\n        }\n    }\n    for (int i : lst2) {\n        if (i % 2 == 0) {\n            even += 1;\n        }\n    }\n    if (even >= odd) {\n        return \"YES\";\n    }\n    return \"NO\";\n}", "pred": "func exchange(lst1: ArrayList<Int64>, lst2: ArrayList<Int64>): String {\n    var odd = 0\n    var even = 0\n    for (i in lst1) {\n        if (i % 2 == 1) {\n            odd += 1\n        }\n    }\n    for (i in lst2) {\n        if (i % 2 == 0) {\n            even += 1\n        }\n    }\n    if (even >= odd) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n"}
{"src": "/**\n * Given a string representing space-separated lowercase letters, return a dictionary\n * of the letter with the most repetitions and their corresponding counts. If several\n * letters have the same occurrence, return all of them.\n * \n * @param test The input string of space-separated lowercase letters.\n * @return A map containing the letter(s) with the maximum occurrences and their counts.\n */\n\npublic Map<String, Integer> histogram(String test) {\n    Map<String, Integer> dict1 = new HashMap<>();\n    List<String> list1 = Arrays.asList(test.split(\" \" ));\n    int t = 0;\n    for (String i : list1) {\n        if (Collections.frequency(list1, i) > t && !i.isEmpty()) {\n            t = Collections.frequency(list1, i);\n        }\n    }\n    if (t > 0) {\n        for (String i : list1) {\n            if (Collections.frequency(list1, i) == t) {\n                dict1.put(i, t);\n            }\n        }\n    }\n    return dict1;\n}", "pred": "public func histogram(test: String): HashMap<String, Int64> {\n    let dict1 = HashMap<String, Int64>()\n    let list1 = test.split(\" \")\n    var t = 0\n    for (i in list1) {\n        if (list1.filter({$0 == i}).size > t &&!i.isEmpty()) {\n            t = list1.filter({$0 == i}).size\n        }\n    }\n    if (t > 0) {\n        for (i in list1) {\n            if (list1.filter({$0 == i}).size == t) {\n                dict1.put(i, t)\n            }\n        }\n    }\n    return dict1\n}\n"}
{"src": "/**\n * Given two strings s and c, delete all characters in s that are equal to any character in c.\n * Then check if the resulting string is a palindrome. A string is called palindrome if it reads\n * the same backward as forward.\n * \n * @param s The original string from which characters will be deleted.\n * @param c The characters to be deleted from the original string.\n * @return A tuple containing the result string after deletion and a boolean indicating whether\n *         the result string is a palindrome (true) or not (false).\n */\n\npublic List<Object> reverseDelete(String s, String c) {\n    StringBuilder sb = new StringBuilder();\n    for (char ch : s.toCharArray()) {\n        if (c.indexOf(ch) == -1) {\n            sb.append(ch);\n        }\n    }\n    return Arrays.asList(sb.toString(), sb.toString().equals(sb.reverse().toString()));\n}", "pred": "public func reverseDelete(s: String, c: String): ArrayList<Any> {\n    let sb = StringBuilder()\n    for (ch in s.toRuneArray()) {\n        if (c.indexOf(ch) == -1) {\n            sb.append(ch)\n        }\n    }\n    return ArrayList<Any>([sb.toString(), sb.toString() == sb.toString().toRuneArray().toString().toRuneArray().toString().toRuneArray().toString()])\n}\n"}
{"src": "/**\n * Given a list of strings where each string consists of only digits,\n * return a list where each element represents \"the number of odd elements in the string i of the input.\"\n * \n * @param lst The list of strings consisting of only digits.\n * @return A list of strings where each string describes the number of odd digits in the corresponding input string.\n */\n\npublic List<String> oddCount(List<String> lst) {\n    List<String> res = new ArrayList<>();\n    for (String arr : lst) {\n        int n = 0;\n        for (char d : arr.toCharArray()) {\n            if ((d - '0') % 2 == 1) {\n                n += 1;\n            }\n        }\n        res.add(\"the number of odd elements \" + n + \"n the str\" + n + \"ng \" + n + \" of the \" + n + \"nput.\" );\n    }\n    return res;\n}", "pred": "public func oddCount(lst: ArrayList<String>): ArrayList<String> {\n    var res: ArrayList<String> = ArrayList<String>()\n    for (arr in lst) {\n        var n: Int64 = 0\n        for (d in arr.toRuneArray()) {\n            if ((Int64(UInt32(d)) - Int64('0')) % 2 == 1) {\n                n += 1\n            }\n        }\n        res.append(\"the number of odd elements \" + n.toString() + \" in the str\" + n.toString() + \"th \" + n.toString() + \" of the \" + n.toString() + \" input.\")\n    }\n    return res\n}\n"}
{"src": "/**\n * Given an array of integers nums, find the minimum sum of any non-empty sub-array of nums.\n * \n * @param nums The list of integers.\n * @return The minimum sum of any non-empty sub-array of nums.\n */\n\npublic int minSubArraySum(List<Integer> nums) {\n    int minSum = Integer.MAX_VALUE;\n    int sum = 0;\n    for (Integer num : nums) {\n        sum += num;\n        if (minSum > sum) {\n            minSum = sum;\n        }\n        if (sum > 0) {\n            sum = 0;\n        }\n    }\n    return minSum;\n}", "pred": "func minSubArraySum(nums: ArrayList<Int64>): Int64 {\n    var minSum = Int64.Max\n    var sum = 0\n    for (num in nums) {\n        sum += num\n        if (minSum > sum) {\n            minSum = sum\n        }\n        if (sum > 0) {\n            sum = 0\n        }\n    }\n    return minSum\n}\n"}
{"src": "/**\n * You are given a rectangular grid of wells. Each row represents a single well,\n * and each 1 in a row represents a single unit of water. Each well has a corresponding bucket\n * that can be used to extract water from it, and all buckets have the same capacity.\n * Your task is to use the buckets to empty the wells and output the number of times you need\n * to lower the buckets.\n * \n * @param grid The rectangular grid representing wells and water units.\n * @param capacity The capacity of each bucket used to extract water.\n * @return The number of times you need to lower the buckets to empty all the wells.\n */\n\npublic int maxFill(List<List<Integer>> grid, int capacity) {\n    int sum = 0;\n    for (List<Integer> arr : grid) {\n        sum += Math.ceil((double) arr.stream().reduce(Integer::sum).get() / capacity);\n    }\n    return sum;\n}", "pred": "func maxFill(grid: ArrayList<ArrayList<Int64>>, capacity: Int64): Int64 {\n    var sum: Int64 = 0\n    for (arr in grid) {\n        sum += ceil((Float64(arr.sum()) / Float64(capacity)))\n    }\n    return sum\n}\n"}
{"src": "/**\n * Sorts an array of non-negative integers according to the number of ones in their binary representation\n * in ascending order. For integers with the same number of ones, sorts based on decimal value.\n * \n * @param arr The list of non-negative integers to be sorted.\n * @return The sorted list of integers based on the specified criteria.\n */\n\npublic int compare(Integer o1, Integer o2) {\n    int cnt1 = (int) Integer.toBinaryString(Math.abs(o1)).chars().filter(ch -> ch == '1').count();\n    int cnt2 = (int) Integer.toBinaryString(Math.abs(o2)).chars().filter(ch -> ch == '1').count();\n    if (cnt1 > cnt2) {\n        return 1;\n    } else if (cnt1 < cnt2) {\n        return -1;\n    } else {\n        return o1.compareTo(o2);\n    }\n}\n});\nreturn sorted_arr;\n}", "pred": "public func sortArrayByOnesCount(arr: ArrayList<Int64>): ArrayList<Int64> {\n    var sorted_arr: ArrayList<Int64> = arr\n    sorted_arr.sortBy({ (o1: Int64, o2: Int64): Bool =>\n        let cnt1 = Int64(math.log2(math.abs(Float64(o1))))\n        let cnt2 = Int64(math.log2(math.abs(Float64(o2))))\n        if (cnt1 > cnt2) {\n            return true\n        } else if (cnt1 < cnt2) {\n            return false\n        } else {\n            return o1 < o2\n        }\n    })\n    return sorted_arr\n}"}
{"src": "/**\n * Given a string s and a natural number n, returns a list of all words from string s\n * that contain exactly n consonants, in the order these words appear in the string s.\n * \n * @param s The input string containing only letters and spaces.\n * @param n The number of consonants to check for in each word.\n * @return A list of words from string s that contain exactly n consonants.\n */\n\npublic List<String> selectWords(String s, int n) {\n    List<String> result = new ArrayList<>();\n    for (String word : s.split(\" \")) {\n        int n_consonants = 0;\n        for (char c : word.toCharArray()) {\n            c = Character.toLowerCase(c);\n            if (\"aeiou\".indexOf(c) == -1) {\n                n_consonants += 1;\n            }\n        }\n        if (n_consonants == n) {\n            result.add(word);\n        }\n    }\n    return result;\n}", "pred": "public func selectWords(s: String, n: Int64): ArrayList<String> {\n    let result = ArrayList<String>()\n    let words = s.split(\" \")\n    for (word in words) {\n        var n_consonants = 0\n        for (c in word.toAsciiLower().toRuneArray()) {\n            if (\"aeiou\".indexOf(c) == -1) {\n                n_consonants += 1\n            }\n        }\n        if (n_consonants == n) {\n            result.append(word)\n        }\n    }\n    return result\n}\n"}
{"src": "/**\n * Given a word, find the closest vowel that stands between two consonants from the right side of the word (case-sensitive).\n * Vowels at the beginning and ending of the word do not count.\n * \n * @param word The input word containing English letters only.\n * @return The closest vowel that meets the specified condition, or an empty string if none is found.\n */\n\npublic String getClosestVowel(String word) {\n    if (word.length() < 3) {\n        return \"\";\n    }\n\n    String vowels = \"aeiouAEIOU\";\n    for (int i = word.length() - 2; i > 0; i--) {\n        if (vowels.indexOf(word.charAt(i)) != -1 && vowels.indexOf(word.charAt(i + 1)) == -1 && vowels.indexOf(word.charAt(i - 1)) == -1) {\n            return String.valueOf(word.charAt(i));\n        }\n    }\n    return \"\";\n}", "pred": "public func getClosestVowel(word: String): String {\n    if (word.size < 3) {\n        return \"\"\n    }\n\n    let vowels = \"aeiouAEIOU\"\n    for (i in (word.size - 2)..=0 : -1) {\n        if (vowels.contains(word[i])) &&!vowels.contains(word[i + 1]) &&!vowels.contains(word[i - 1])) {\n            return word[i].toString()\n        }\n    }\n    return \"\"\n}\n"}
{"src": "/**\n * Given a list of two strings, both strings consist of open parentheses \"(\" or close parentheses \")\" only.\n * Check if it is possible to concatenate the two strings in some order such that the resulting string is balanced\n * (all parentheses are matched).\n * \n * @param lst The list containing two strings of parentheses.\n * @return \"Yes\" if it's possible to concatenate the strings to form a balanced string, otherwise \"No\".\n */\n\npublic String matchParens(List<String> lst) {\n    List<String> S = Arrays.asList(lst.get(0) + lst.get(1), lst.get(1) + lst.get(0));\n    for (String s : S) {\n        int val = 0;\n        for (char i : s.toCharArray()) {\n            if (i == '(') {\n                val += 1;\n            } else {\n                val -= 1;\n            }\n            if (val < 0) {\n                break;\n            }\n        }\n        if (val == 0) {\n            return \"Yes\";\n        }\n    }\n    return \"No\";\n}", "pred": "public func matchParens(lst: ArrayList<String>): String {\n    let S = ArrayList<String>([lst[0] + lst[1], lst[1] + lst[0]])\n    for (s in S) {\n        var val = 0\n        for (i in s.toRuneArray()) {\n            if (i == '(') {\n                val += 1\n            } else {\n                val -= 1\n            }\n            if (val < 0) {\n                break\n            }\n        }\n        if (val == 0) {\n            return \"Yes\"\n        }\n    }\n    return \"No\"\n}\n"}
{"src": "/**\n * Given an array arr of integers and a positive integer k, return a sorted list of length k\n * with the maximum k numbers in arr.\n * \n * @param arr The input array of integers.\n * @param k The length of the sorted list to return.\n * @return A sorted list of the maximum k numbers in arr.\n */\n\npublic List<Integer> maximum(List<Integer> arr, int k) {\n    if (k == 0) {\n        return List.of();\n    }\n    List<Integer> arr_sort = new ArrayList<>(arr);\n    Collections.sort(arr_sort);\n    return arr_sort.subList(arr_sort.size() - k, arr_sort.size());\n}", "pred": "public func maximum(arr: ArrayList<Int64>, k: Int64): ArrayList<Int64> {\n    if (k == 0) {\n        return ArrayList<Int64>()\n    }\n    var arr_sort = arr\n    arr_sort.sortBy({ rht: Int64, lht: Int64 =>\n        if (rht < lht) {\n            return Ordering.GT\n        }\n        if (rht > lht) {\n            return Ordering.LT\n        }\n        return Ordering.EQ\n    }, stable: true)\n    return arr_sort[arr_sort.size - k..arr_sort.size]\n}\n"}
{"src": "/**\n * Given a non-empty list of integers, return the sum of all odd elements that are in even positions (0-based index).\n * \n * @param lst The list of integers.\n * @return The sum of all odd elements that are in even positions.\n */\n\npublic int solution(List<Integer> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if ((lst.get(i) % 2) == 1) {\n            sum += lst.get(i);\n        }\n    }\n    return sum;\n}", "pred": "func solution(lst: ArrayList<Int64>): Int64 {\n    var sum: Int64 = 0\n    for (i in 0..lst.size : 2) {\n        if ((lst[i] % 2) == 1) {\n            sum += lst[i]\n        }\n    }\n    return sum\n}\n"}
{"src": "/**\n * Given a non-empty array of integers arr and an integer k,\n * return the sum of the elements with at most two digits from the first k elements of arr.\n * \n * @param arr The list of integers.\n * @param k The number of elements to consider from the start of arr.\n * @return The sum of the elements with at most two digits from the first k elements of arr.\n */\n\npublic int addElements(List<Integer> arr, int k) {\n    arr = arr.subList(0, k);\n    Optional<Integer> sum = arr.stream().filter(p -> String.valueOf(Math.abs(p)).length() <= 2).reduce(Integer::sum);\n    return sum.orElse(0);\n}", "pred": "func addElements(arr: ArrayList<Int64>, k: Int64): Int64 {\n    var sum: Int64 = 0\n    for (i in 0..k) {\n        if (String(math.abs(arr[i])).size <= 2) {\n            sum += arr[i]\n        }\n    }\n    return sum\n}\n"}
{"src": "/**\n * Given a positive integer n, return a sorted list of the odd numbers in the Collatz sequence starting from n.\n * The Collatz sequence is defined as follows:\n * - Start with any positive integer n.\n * - Each term is obtained from the previous term as follows:\n *   - If the previous term is even, the next term is one half of the previous term.\n *   - If the previous term is odd, the next term is 3 times the previous term plus 1.\n * - The sequence is expected to eventually reach 1 (Collatz conjecture).\n * \n * @param n The starting integer for the Collatz sequence.\n * @return A sorted list of the odd numbers in the Collatz sequence starting from n.\n */\n\npublic List<Integer> getOddCollatz(int n) {\n    List<Integer> odd_collatz = new ArrayList<>();\n    if (n % 2 == 1) {\n        odd_collatz.add(n);\n    }\n    while (n > 1) {\n        if (n % 2 == 0) {\n            n = n / 2;\n        } else {\n            n = n * 3 + 1;\n        }\n        if (n % 2 == 1) {\n            odd_collatz.add(n);\n        }\n    }\n    Collections.sort(odd_collatz);\n    return odd_collatz;\n}", "pred": "public func getOddCollatz(n: Int64): ArrayList<Int64> {\n    var odd_collatz: ArrayList<Int64> = ArrayList<Int64>()\n    if (n % 2 == 1) {\n        odd_collatz.append(n)\n    }\n    var num = n\n    while (num > 1) {\n        if (num % 2 == 0) {\n            num = num / 2\n        } else {\n            num = num * 3 + 1\n        }\n        if (num % 2 == 1) {\n            odd_collatz.append(num)\n        }\n    }\n    odd_collatz.sortBy({a: Int64, b: Int64 =>\n        if (a < b) {\n            return Ordering.LT\n        }\n        if (a > b) {\n            return Ordering.GT\n        }\n        return Ordering.EQ\n    })\n    return odd_collatz\n}\n"}
{"src": "/**\n * Validates a given date string based on specific rules.\n * \n * The date is considered valid if:\n * 1. The date string is not empty.\n * 2. The format is \"mm-dd-yyyy\".\n * 3. The month is between 1 and 12 inclusive.\n * 4. The day is valid based on the month:\n *    - Months with 31 days: 1, 3, 5, 7, 8, 10, 12.\n *    - Months with 30 days: 4, 6, 9, 11.\n *    - February (month 2) has 28 or 29 days based on leap year (not validated here).\n * \n * @param date The date string to validate.\n * @return true if the date is valid, otherwise false.\n */\n\npublic boolean validDate(String date) {\n    try {\n        date = date.strip();\n        String[] dates = date.split(\"-\" );\n        String m = dates[0];\n        while (!m.isEmpty() && m.charAt(0) == '0') {\n            m = m.substring(1);\n        }\n        String d = dates[1];\n        while (!d.isEmpty() && d.charAt(0) == '0') {\n            d = d.substring(1);\n        }\n        String y = dates[2];\n        while (!y.isEmpty() && y.charAt(0) == '0') {\n            y = y.substring(1);\n        }\n        int month = Integer.parseInt(m), day = Integer.parseInt(d), year = Integer.parseInt(y);\n        if (month < 1 || month > 12) {\n            return false;\n        }\n        if (Arrays.asList(1, 3, 5, 7, 8, 10, 12).contains(month) && (day < 1 || day > 31)) {\n            return false;\n        }\n        if (Arrays.asList(4, 6, 9, 11).contains(month) && (day < 1 || day > 30)) {\n            return false;\n        }\n        if (month == 2 && (day < 1 || day > 29)) {\n            return false;\n        }\n        return true;\n    } catch (Exception e) {\n        return false;\n    }\n}", "pred": "public func validDate(date: String): Bool {\n    try {\n        let dates = date.split(\"-\")\n        let m = dates[0]\n        while (!m.isEmpty() && m.charAt(0) == '0') {\n            m = m[1..m.size]\n        }\n        let d = dates[1]\n        while (!d.isEmpty() && d.charAt(0) == '0') {\n            d = d[1..d.size]\n        }\n        let y = dates[2]\n        while (!y.isEmpty() && y.charAt(0) == '0') {\n            y = y[1..y.size]\n        }\n        let month = Int64.parse(m)\n        let day = Int64.parse(d)\n        let year = Int64.parse(y)\n        if (month < 1 || month > 12) {\n            return false\n        }\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && (day < 1 || day > 31)) {\n            return false\n        }\n        if (month == 4 || month == 6 || month == 9 || month == 11) && (day < 1 || day > 30)) {\n            return false\n        }\n        if (month == 2 && (day < 1 || day > 29)) {\n            return false\n        }\n        return true\n    } catch (e: Exception) {\n        return false\n    }\n}"}
{"src": "/**\n * Given a string of words, perform the following tasks:\n * - If the string contains whitespace, split the words on whitespace and return them in a list.\n * - If the string contains commas but no whitespace, split the words on commas and return them in a list.\n * - If the string contains neither whitespace nor commas, count the number of lowercase letters\n *   with odd order in the alphabet ('a' = 0, 'b' = 1, ..., 'z' = 25) and return the count.\n * \n * @param txt The input string containing words.\n * @return A list of words split based on whitespace or commas, or the count of odd-order lowercase letters.\n */\n\npublic Object splitWords(String txt) {\n    if (txt.contains(\" \" )) {\n        return Arrays.asList(txt.split(\" \" ));\n    } else if (txt.contains(\",\" )) {\n        return Arrays.asList(txt.split(\"[,\\s]\" ));\n    } else {\n        int count = 0;\n        for (char c : txt.toCharArray()) {\n            if (Character.isLowerCase(c) && (c - 'a') % 2 == 1) {\n                count += 1;\n            }\n        }\n        return count;\n    }\n}", "pred": "public func splitWords(txt: String): ArrayList<String> {\n    if (txt.contains(\" \")) {\n        return txt.split(\" \").toArrayList()\n    } else if (txt.contains(\",\" )) {\n        return txt.split(\"[,\\s]\").toArrayList()\n    } else {\n        var count = 0\n        for (c in txt.toRuneArray()) {\n            if (UInt32(c) >= UInt32('a') && UInt32(c) <= UInt32('z')) {\n                if ((UInt32(c) - UInt32('a')) % 2 == 1) {\n                    count += 1\n                }\n            }\n        }\n        return ArrayList<String>([count])\n    }\n}"}
{"src": "/**\n * Given a list of numbers, checks whether they are sorted in ascending order without any duplicates.\n * \n * @param lst The list of integers to be checked.\n * @return True if the list is sorted in ascending order without duplicates, false otherwise.\n */\npublic boolean isSorted(List<Integer> lst) {\n    List<Integer> sorted_lst = new ArrayList<>(lst);\n    Collections.sort(sorted_lst);\n    if (!lst.equals(sorted_lst)) {\n        return false;\n    }\n    for (int i = 0; i < lst.size() - 2; i++) {\n        if (lst.get(i) == lst.get(i + 1) && lst.get(i) == lst.get(i + 2)) {\n            return false;\n        }\n    }\n    return true;\n}", "pred": "public func isSorted(lst: ArrayList<Int64>): Bool {\n    let sorted_lst = ArrayList<Int64>(lst)\n    sorted_lst.sortBy({a: Int64, b: Int64 =>\n        if (a < b) {\n            return Ordering.LT\n        }\n        if (a > b) {\n            return Ordering.GT\n        }\n        return Ordering.EQ\n    })\n    if (!lst.equals(sorted_lst)) {\n        return false\n    }\n    for (i in 0..lst.size - 2) {\n        if (lst[i] == lst[i + 1] && lst[i] == lst[i + 2]) {\n            return false\n        }\n    }\n    return true\n}\n"}
{"src": "/**\n * Determines whether the length of intersection of two intervals is a prime number.\n * \n * @param interval1 The first interval represented as a pair of integers (start, end).\n * @param interval2 The second interval represented as a pair of integers (start, end).\n * @return \"YES\" if the length of the intersection is a prime number, otherwise \"NO\".\n */\n\npublic String intersection(List<Integer> interval1, List<Integer> interval2) {\n    int l = Math.max(interval1.get(0), interval2.get(0));\n    int r = Math.min(interval1.get(1), interval2.get(1));\n    int length = r - l;\n    if (length <= 0) {\n        return \"NO\";\n    }\n    if (length == 1) {\n        return \"NO\";\n    }\n    if (length == 2) {\n        return \"YES\";\n    }\n    for (int i = 2; i < length; i++) {\n        if (length % i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}", "pred": "func intersection(interval1: ArrayList<Int64>, interval2: ArrayList<Int64>): String {\n    let l = math.max(interval1[0], interval2[0])\n    let r = math.min(interval1[1], interval2[1])\n    let length = r - l\n    if (length <= 0) {\n        return \"NO\"\n    }\n    if (length == 1) {\n        return \"NO\"\n    }\n    if (length == 2) {\n        return \"YES\"\n    }\n    for (i in 2..length) {\n        if (length % i == 0) {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n"}
{"src": "/**\n * Computes the sum of magnitudes of integers multiplied by the product of all signs \n * (represented by 1, -1, or 0) of each number in the array.\n * \n * @param arr The array of integers.\n * @return The result as an Optional<Integer>. Returns None if the array is empty.\n */\n\npublic Optional<Integer> prodSigns(List<Integer> arr) {\n    if (arr.size() == 0) {\n        return Optional.empty();\n    }\n    if (arr.contains(0)) {\n        return Optional.of(0);\n    }\n    int prod = (int) (-2 * (arr.stream().filter(p -> p < 0).count() % 2) + 1);\n    return Optional.of(prod * (arr.stream().map(Math::abs).reduce(Integer::sum)).get());\n}", "pred": "public func prodSigns(arr: ArrayList<Int64>): Option<Int64> {\n    if (arr.size == 0) {\n        return Option<Int64>.None\n    }\n    if (arr.contains(0)) {\n        return Option<Int64>.Some(0)\n    }\n    var prod: Int64 = -2 * (Int64(arr.filter({ p: Int64 => p < 0}).size % 2) + 1)\n    return Option<Int64>.Some(prod * (arr.map({ p: Int64 => math.abs(p)}).reduce({ (a: Int64, b: Int64) => a + b})))\n}\n"}
{"src": "/**\n * Finds the minimum path of length k in a given N x N grid.\n * \n * @param grid The N x N grid where each cell contains a unique integer in the range [1, N * N].\n * @param k The length of the path (number of cells to visit).\n * @return An ordered list of values on the cells that the minimum path goes through.\n */\n\npublic List<Integer> minPath(List<List<Integer>> grid, int k) {\n    int n = grid.size();\n    int val = n * n + 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid.get(i).get(j) == 1) {\n                List<Integer> temp = new ArrayList<>();\n                if (i != 0) {\n                    temp.add(grid.get(i - 1).get(j));\n                }\n                if (j != 0) {\n                    temp.add(grid.get(i).get(j - 1));\n                }\n                if (i != n - 1) {\n                    temp.add(grid.get(i + 1).get(j));\n                }\n                if (j != n - 1) {\n                    temp.add(grid.get(i).get(j + 1));\n                }\n                val = Collections.min(temp);\n            }\n        }\n    }\n    List<Integer> ans = new ArrayList<>();\n    for (int i = 0; i < k; i++) {\n        if (i % 2 == 0) {\n            ans.add(1);\n        } else {\n            ans.add(val);\n        }\n    }\n    return ans;\n}", "pred": "public func minPath(grid: ArrayList<ArrayList<Int64>>, k: Int64): ArrayList<Int64> {\n    let n = grid.size\n    var val = n * n + 1\n    for (i in 0..n) {\n        for (j in 0..n) {\n            if (grid[i][j] == 1) {\n                var temp = ArrayList<Int64>()\n                if (i!= 0) {\n                    temp.append(grid[i - 1][j])\n                }\n                if (j!= 0) {\n                    temp.append(grid[i][j - 1])\n                }\n                if (i!= n - 1) {\n                    temp.append(grid[i + 1][j])\n                }\n                if (j!= n - 1) {\n                    temp.append(grid[i][j + 1])\n                }\n                val = min(temp)\n            }\n        }\n    }\n    var ans = ArrayList<Int64>()\n    for (i in 0..k) {\n        if (i % 2 == 0) {\n            ans.append(1)\n        } else {\n            ans.append(val)\n        }\n    }\n    return ans\n}\n"}
{"src": "/**\n * Computes the first n + 1 numbers of the Tribonacci sequence.\n * \n * @param n A non-negative integer specifying the number of sequence elements to generate.\n * @return A list containing the first n + 1 numbers of the Tribonacci sequence.\n */\n\npublic List<Integer> tri(int n) {\n    if (n == 0) {\n        return List.of(1);\n    }\n    List<Integer> my_tri = new ArrayList<>(Arrays.asList(1, 3));\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) {\n            my_tri.add(i / 2 + 1);\n        } else {\n            my_tri.add(my_tri.get(my_tri.size() - 1) + my_tri.get(my_tri.size() - 2) + (i + 3) / 2);\n        }\n    }\n    return my_tri;\n}", "pred": "func tri(n: Int64): ArrayList<Int64> {\n    if (n == 0) {\n        return ArrayList<Int64>([1])\n    }\n    var my_tri: ArrayList<Int64> = ArrayList<Int64>([1, 3])\n    for (i in 2..=n) {\n        if (i % 2 == 0) {\n            my_tri.append(i / 2 + 1)\n        } else {\n            my_tri.append(my_tri[my_tri.size - 1] + my_tri[my_tri.size - 2] + (i + 3) / 2)\n        }\n    }\n    return my_tri\n}\n"}
{"src": "/**\n * Computes the product of the odd digits of a positive integer n.\n * Returns 0 if all digits are even.\n * \n * @param n A positive integer.\n * @return The product of the odd digits of n, or 0 if all digits are even.\n */\n\npublic int digits(int n) {\n    int product = 1, odd_count = 0;\n    for (char digit : String.valueOf(n).toCharArray()) {\n        int int_digit = digit - '0';\n        if (int_digit % 2 == 1) {\n            product *= int_digit;\n            odd_count += 1;\n        }\n    }\n    if (odd_count == 0) {\n        return 0;\n    } else {\n        return product;\n    }\n}", "pred": "func digits(n: Int64): Int64 {\n    var product: Int64 = 1\n    var odd_count: Int64 = 0\n    for (digit in n.toString().toRuneArray()) {\n        let int_digit = Int64(UInt32(digit) - UInt32('0'))\n        if (int_digit % 2 == 1) {\n            product *= int_digit\n            odd_count += 1\n        }\n    }\n    if (odd_count == 0) {\n        return 0\n    } else {\n        return product\n    }\n}\n"}
{"src": "/**\n * Determines whether there is a valid nested subsequence of square brackets in the input string.\n * \n * @param string A string consisting only of square brackets.\n * @return true if there exists a valid nested subsequence of brackets; otherwise, false.\n */\n\npublic boolean isNested(String string) {\n    List<Integer> opening_bracket_index = new ArrayList<>(), closing_bracket_index = new ArrayList<>();\n    for (int i = 0; i < string.length(); i++) {\n        if (string.charAt(i) == '[') {\n            opening_bracket_index.add(i);\n        } else {\n            closing_bracket_index.add(i);\n        }\n    }\n    Collections.reverse(closing_bracket_index);\n    int i = 0, l = closing_bracket_index.size();\n    for (int idx : opening_bracket_index) {\n        if (i < l && idx < closing_bracket_index.get(i)) {\n            i += 1;\n        }\n    }\n    return i >= 2;\n}", "pred": "func isNested(string: String): Bool {\n    var opening_bracket_index = ArrayList<Int64>()\n    var closing_bracket_index = ArrayList<Int64>()\n    for (i in 0..string.size) {\n        if (string[i] == '[') {\n            opening_bracket_index.append(i)\n        } else {\n            closing_bracket_index.append(i)\n        }\n    }\n    closing_bracket_index.reverse()\n    var i = 0\n    let l = closing_bracket_index.size\n    for (idx in opening_bracket_index) {\n        if (i < l && idx < closing_bracket_index[i]) {\n            i += 1\n        }\n    }\n    return i >= 2\n}\n"}
{"src": "/**\n * Computes the sum of squared numbers in the given list after rounding each element to the nearest integer (Ceiling).\n * \n * @param lst A list of numbers (doubles).\n * @return The sum of squared rounded numbers in the list.\n */\n\npublic int sumSquares(List<Double> lst) {\n    return lst.stream().map(p -> (int) Math.ceil(p)).map(p -> p * p).reduce(Integer::sum).get();\n}", "pred": "func sumSquares(lst: ArrayList<Float64>): Int64 {\n    return lst.map { p => math.ceil(p) }.map { p => Int64(p * p) }.reduce { a, b => a + b }\n}\n"}
{"src": "/**\n * Checks if the last character of a given string is an alphabetical character and is not part of a word.\n * \n * @param txt The input string to be checked.\n * @return true if the last character is an alphabetical character and not part of a word; otherwise, false.\n */\n\npublic boolean checkIfLastCharIsALetter(String txt) {\n    String[] words = txt.split(\" \", -1);\n    String check = words[words.length - 1];\n    return check.length() == 1 && Character.isLetter(check.charAt(0));\n}", "pred": "public func checkIfLastCharIsALetter(txt: String): Bool {\n    let words = txt.split(\" \")\n    let check = words[words.size - 1]\n    return check.size == 1 && check.toRuneArray()[0].isAsciiLetter()\n}\n"}
{"src": "/**\n * Finds the largest index of an element in the list that is not greater than or equal to the element immediately preceding it.\n * If no such element exists, returns -1.\n * \n * @param arr The list of integers.\n * @return The largest index of an element that does not meet the condition, or -1 if no such element exists.\n */\n\npublic int canArrange(List<Integer> arr) {\n    int ind = -1, i = 1;\n    while (i < arr.size()) {\n        if (arr.get(i) < arr.get(i - 1)) {\n            ind = i;\n        }\n        i += 1;\n    }\n    return ind;\n}", "pred": "public func canArrange(arr: ArrayList<Int64>): Int64 {\n    var ind: Int64 = -1\n    var i: Int64 = 1\n    while (i < arr.size) {\n        if (arr[i] < arr[i - 1]) {\n            ind = i\n        }\n        i += 1\n    }\n    return ind\n}\n"}
{"src": "/**\n * Returns a tuple (a, b), where 'a' is the largest of negative integers and 'b' is the smallest of positive integers in a list.\n * If there are no negative or positive integers, returns them as None.\n * \n * @param lst The list of integers.\n * @return A list containing two Optionals: the first Optional containing the largest negative integer (or empty if none), \n *         and the second Optional containing the smallest positive integer (or empty if none).\n */\n\npublic List<Optional<Integer>> largestSmallestIntegers(List<Integer> lst){\n    List<Integer> smallest = lst.stream().filter(p -> p < 0).toList();\n    List<Integer> largest = lst.stream().filter(p -> p > 0).toList();\n    Optional<Integer> s = Optional.empty();\n    if (smallest.size() > 0) {\n        s = Optional.of(Collections.max(smallest));\n    }\n    Optional<Integer> l = Optional.empty();\n    if (largest.size() > 0) {\n        l = Optional.of(Collections.min(largest));\n    }\n    return Arrays.asList(s, l);\n}", "pred": "public func largestSmallestIntegers(lst: ArrayList<Int64>): ArrayList<Option<Int64>> {\n    let smallest = lst.filter({ p -> p < 0})\n    let largest = lst.filter({ p -> p > 0})\n    var s: Option<Int64> = Option<Int64>.None\n    if (smallest.size > 0) {\n        s = largest.max()\n    }\n    var l: Option<Int64> = Option<Int64>.None\n    if (largest.size > 0) {\n        l = smallest.min()\n    }\n    return ArrayList<Option<Int64>>([s, l])\n}\n"}
{"src": "/**\n * Compares two values (integers, floats, or strings representing real numbers) and returns the larger variable in its given variable type.\n * Returns None if the values are equal.\n * \n * @param a The first value (integer, float, or string).\n * @param b The second value (integer, float, or string).\n * @return An Optional containing the larger variable of the given type, or Optional.empty() if the values are equal.\n */\n\npublic Optional<Object> compareOne(Object a, Object b) {\n    double temp_a = 0, temp_b = 0;\n    if (a instanceof Integer) {\n        temp_a = (Integer) a * 1.0;\n    } else if (a instanceof Double) {\n        temp_a = (double) a;\n    } else if (a instanceof String) {\n        temp_a = Double.parseDouble(((String) a).replace(',', '.'));\n    }\n    if (b instanceof Integer) {\n        temp_b = (Integer) b * 1.0;\n    } else if (b instanceof Double) {\n        temp_b = (double) b;\n    } else if (b instanceof String) {\n        temp_b = Double.parseDouble(((String) b).replace(',', '.'));\n    }\n    if (temp_a == temp_b) {\n        return Optional.empty();\n    } else if (temp_a > temp_b) {\n        return Optional.of(a);\n    } else {\n        return Optional.of(b);\n    }\n}", "pred": "public func compareOne(a: Any, b: Any): Option<Any> {\n    var temp_a: Float64 = 0.0\n    var temp_b: Float64 = 0.0\n    if (a is Int64) {\n        temp_a = Float64(a) * 1.0\n    } else if (a is Float64) {\n        temp_a = Float64(a)\n    } else if (a is String) {\n        temp_a = Float64.parse((a as String).replace(\",\", \".\"))\n    }\n    if (b is Int64) {\n        temp_b = Float64(b) * 1.0\n    } else if (b is Float64) {\n        temp_b = Float64(b)\n    } else if (b is String) {\n        temp_b = Float64.parse((b as String).replace(\",\", \".\"))\n    }\n    if (temp_a == temp_b) {\n        return Option<Any>.None\n    } else if (temp_a > temp_b) {\n        return Option<Any>.Some(a)\n    } else {\n        return Option<Any>.Some(b)\n    }\n}"}
{"src": "/**\n * Determines whether the given number n can be written as the sum of exactly 4 positive even numbers.\n * \n * @param n The number to evaluate.\n * @return true if n can be expressed as the sum of exactly 4 positive even numbers; otherwise, false.\n */\n\npublic boolean isEqualToSumEven(int n) {\n    return n % 2 == 0 && n >= 8;\n}", "pred": "func isEqualToSumEven(n: Int64): Bool {\n    return n % 2 == 0 && n >= 8\n}\n"}
{"src": "/**\n * Computes the Brazilian factorial of a positive integer n, defined as n! * (n-1)! * (n-2)! * ... * 1!.\n * \n * @param n The integer input (n > 0) for which to compute the special factorial.\n * @return The special factorial of the input integer.\n */\n\npublic long specialFactorial(int n) {\n    long fact_i = 1, special_fact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact_i *= i;\n        special_fact *= fact_i;\n    }\n    return special_fact;\n}", "pred": "public func specialFactorial(n: Int64): Int64 {\n    var fact_i: Int64 = 1\n    var special_fact: Int64 = 1\n    for (i in 1..=n) {\n        fact_i *= i\n        special_fact *= fact_i\n    }\n    return special_fact\n}\n"}
{"src": "/**\n * Replaces all spaces in the input string with underscores.\n * Also replaces consecutive spaces (more than 2) with a single dash (-).\n * \n * @param text The input string to be processed.\n * @return The processed string with spaces replaced as described.\n */\n\npublic String fixSpaces(String text) {\n    StringBuilder sb = new StringBuilder();\n    int start = 0, end = 0;\n    for (int i = 0; i < text.length(); i++) {\n        if (text.charAt(i) == ' ') {\n            end += 1;\n        } else {\n            if (end - start > 2) {\n                sb.append('-');\n            } else if (end - start > 0) {\n                sb.append(\"_\".repeat(end - start));\n            }\n            sb.append(text.charAt(i));\n            start = i + 1;\n            end = i + 1;\n        }\n    }\n    if (end - start > 2) {\n        sb.append('-');\n    } else if (end - start > 0) {\n        sb.append(\"_\".repeat(end - start));\n    }\n    return sb.toString();\n}", "pred": "public func fixSpaces(text: String): String {\n    var sb: StringBuilder = StringBuilder()\n    var start: Int64 = 0\n    var end: Int64 = 0\n    for (i in 0..text.size) {\n        if (text[i] =='') {\n            end += 1\n        } else {\n            if (end - start > 2) {\n                sb.append('-')\n            } else if (end - start > 0) {\n                sb.append(text[start..end])\n            }\n            sb.append(text[i])\n            start = i + 1\n            end = i + 1\n        }\n    }\n    if (end - start > 2) {\n        sb.append('-')\n    } else if (end - start > 0) {\n        sb.append(text[start..end])\n    }\n    return sb.toString()\n}\n"}
{"src": "/**\n * Checks if the given file name is valid based on specific criteria:\n * \n * 1. The file name should not contain more than three digits ('0'-'9').\n * 2. The file name must contain exactly one dot '.'.\n * 3. The substring before the dot should not be empty and must start with a letter from the Latin alphabet ('a'-'z' or 'A'-'Z').\n * 4. The substring after the dot should be one of the following: \"txt\", \"exe\", \"dll\".\n * \n * @param file_name The file name to be checked.\n * @return \"Yes\" if the file name meets all the criteria; otherwise, \"No\".\n */\n\npublic String filenameCheck(String file_name) {\n    List<String> suf = Arrays.asList(\"txt\", \"exe\", \"dll\");\n    String[] lst = file_name.split(\"\\\\.\" );\n    if (lst.length != 2 || !suf.contains(lst[1]) || lst[0].isEmpty() || !Character.isLetter(lst[0].charAt(0))) {\n        return \"No\";\n    }\n    int t = (int) lst[0].chars().map(x -> (char) x).filter(Character::isDigit).count();\n    if (t > 3) {\n        return \"No\";\n    }\n    return \"Yes\";\n}", "pred": "public func filenameCheck(file_name: String): String {\n    let suf = [\"txt\", \"exe\", \"dll\"]\n    let lst = file_name.split(\".\")\n    if (lst.size!= 2 ||!suf.contains(lst[1]) || lst[0].isEmpty() ||!lst[0].toAsciiLower().toRuneArray().first().isAsciiLower()) {\n        return \"No\"\n    }\n    let t = lst[0].toAsciiLower().toRuneArray().filter({x => x.isAsciiDigit()}).size\n    if (t > 3) {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n"}
{"src": "/**\n * Modifies the entries in a list of integers based on their index:\n * - Squares the integer entry if its index is a multiple of 3.\n * - Cubes the integer entry if its index is a multiple of 4 and not a multiple of 3.\n * Entries at other indexes remain unchanged.\n * \n * @param lst The list of integers to be modified.\n * @return The sum of all entries in the list after modification.\n */\n\npublic int sumSquares(List<Integer> lst) {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            result.add(lst.get(i) * lst.get(i));\n        } else if (i % 4 == 0) {\n            result.add((int) Math.pow(lst.get(i), 3));\n        } else {\n            result.add(lst.get(i));\n        }\n    }\n    return result.stream().reduce(Integer::sum).orElse(0);\n}", "pred": "public func sumSquares(lst: ArrayList<Int64>): Int64 {\n    var result: ArrayList<Int64> = ArrayList<Int64>()\n    for (i in 0..lst.size) {\n        if (i % 3 == 0) {\n            result.append(lst[i] * lst[i])\n        } else if (i % 4 == 0) {\n            result.append(Int64(math.pow(Float64(lst[i]), 3.0)))\n        } else {\n            result.append(lst[i])\n        }\n    }\n    return result.reduce({x, y => x + y})?? 0\n}\n"}
{"src": "/**\n * Extracts words from a sentence whose lengths are prime numbers.\n * \n * @param sentence The input sentence containing words separated by spaces.\n * @return A string containing words from the original sentence whose lengths are prime numbers,\n *         preserving the order of words as in the original sentence.\n */\n\npublic String wordsInSentence(String sentence) {\n    List<String> new_lst = new ArrayList<>();\n    for (String word : sentence.split(\" \" )) {\n        boolean flg = true;\n        if (word.length() == 1) {\n            continue;\n        }\n        for (int i = 2; i < word.length(); i++) {\n            if (word.length() % i == 0) {\n                flg = false;\n                break;\n            }\n        }\n        if (flg) {\n            new_lst.add(word);\n        }\n    }\n    return String.join(\" \", new_lst);\n}", "pred": "public func wordsInSentence(sentence: String): String {\n    let new_lst: ArrayList<String> = ArrayList<String>()\n    for (word in sentence.split(\" \")) {\n        var flg: Bool = true\n        if (word.size == 1) {\n            continue\n        }\n        for (i in 2..word.size) {\n            if (word.size % i == 0) {\n                flg = false\n                break\n            }\n        }\n        if (flg) {\n            new_lst.append(word)\n        }\n    }\n    return new_lst.joinToString(separator: \" \")\n}\n"}
{"src": "/**\n * Determines whether the product of two fractions x * n evaluates to a whole number.\n * Both x and n are string representations of fractions in the format <numerator>/<denominator>,\n * where both numerator and denominator are positive whole numbers.\n * \n * @param x The first fraction as a string (<numerator>/<denominator>).\n * @param n The second fraction as a string (<numerator>/<denominator>).\n * @return true if the product x * n evaluates to a whole number; otherwise, false.\n */\n\npublic boolean simplify(String x, String n) {\n    String[] a = x.split(\"/\");\n    String[] b = n.split(\"/\");\n    int numerator = Integer.parseInt(a[0]) * Integer.parseInt(b[0]);\n    int denom = Integer.parseInt(a[1]) * Integer.parseInt(b[1]);\n    return numerator / denom * denom == numerator;\n}", "pred": "func simplify(x: String, n: String): Bool {\n    let a = x.split(\"/\")\n    let b = n.split(\"/\")\n    let numerator = Int64.parse(a[0]) * Int64.parse(b[0])\n    let denominator = Int64.parse(a[1]) * Int64.parse(b[1])\n    return numerator / denominator * denominator == numerator\n}\n"}
{"src": "/**\n * Sorts the given list of integers in ascending order according to the sum of their digits.\n * If multiple items have the same sum of digits, they are ordered based on their index in the original list.\n * \n * @param nums The list of integers to be sorted.\n * @return The sorted list of integers based on the sum of their digits.\n */\n\npublic List<Integer> orderByPoints(List<Integer> nums) {\n    List<Integer> result = new ArrayList<>(nums);\n    result.sort((o1, o2) -> {\n        int sum1 = 0;\n        int sum2 = 0;\n\n        for (int i = 0; i < String.valueOf(o1).length(); i++) {\n            if (i != 0 || o1 >= 0) {\n                sum1 += (String.valueOf(o1).charAt(i) - '0' );\n                if (i == 1 && o1 < 0) {\n                    sum1 = -sum1;\n                }\n            }\n        }\n        for (int i = 0; i < String.valueOf(o2).length(); i++) {\n            if (i != 0 || o2 >= 0) {\n                sum2 += (String.valueOf(o2).charAt(i) - '0' );\n                if (i == 1 && o2 < 0) {\n                    sum2 = -sum2;\n                }\n            }\n        }\n        return Integer.compare(sum1, sum2);\n    });\n    return result;\n}", "pred": "public func orderByPoints(nums: ArrayList<Int64>): ArrayList<Int64> {\n    var result: ArrayList<Int64> = nums\n    result.sortBy({ o1: Int64, o2: Int64 =>\n        var sum1: Int64 = 0\n        var sum2: Int64 = 0\n        for (i in 0..o1.toString().size) {\n            if (i!= 0 || o1 >= 0) {\n                sum1 += Int64(UInt32(o1.toString().toRuneArray()[i])) - Int64(UInt32('0'))\n                if (i == 1 && o1 < 0) {\n                    sum1 = -sum1\n                }\n            }\n        }\n        for (i in 0..o2.toString().size) {\n            if (i!= 0 || o2 >= 0) {\n                sum2 += Int64(UInt32(o2.toString().toRuneArray()[i])) - Int64(UInt32('0'))\n                if (i == 1 && o2 < 0) {\n                    sum2 = -sum2\n                }\n            }\n        }\n        if (sum1 < sum2) {\n            return Ordering.LT\n        }\n        if (sum1 > sum2) {\n            return Ordering.GT\n        }\n        return Ordering.EQ\n    })\n    return result\n}\n"}
{"src": "/**\n * Counts the number of elements in the list that are greater than 10\n * and have both their first and last digits as odd numbers (1, 3, 5, 7, 9).\n * \n * @param nums The list of numbers to be filtered and counted.\n * @return The count of elements meeting the specified conditions.\n */\n\npublic int specialFilter(List<Integer> nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            String odd_digits = \"13579\";\n            String number_as_string = String.valueOf(num);\n            if (odd_digits.indexOf(number_as_string.charAt(0)) != -1 && odd_digits.indexOf(number_as_string.charAt(number_as_string.length() - 1)) != -1) {\n                count += 1;\n            }\n        }\n    }\n    return count;\n}", "pred": "func specialFilter(nums: ArrayList<Int64>): Int64 {\n    var count: Int64 = 0\n    for (num in nums) {\n        if (num > 10) {\n            let odd_digits = \"13579\"\n            let number_as_string = num.toString()\n            if (odd_digits.contains(number_as_string.charAt(0).toString()) && odd_digits.contains(number_as_string.charAt(number_as_string.size - 1).toString())) {\n                count += 1\n            }\n        }\n    }\n    return count\n}\n"}
{"src": "/**\n * Creates an integer array based on the given positive integer n,\n * where each element a[i] = i * i - i + 1.\n * Returns the number of triples (a[i], a[j], a[k]) where i < j < k,\n * and a[i] + a[j] + a[k] is a multiple of 3.\n * \n * @param n The length of the integer array to be created.\n * @return The number of valid triples meeting the specified conditions.\n */\n\npublic int getMaxTriples(int n) {\n    List<Integer> A = new ArrayList<>();\n    for (int i = 1; i <= n; i++) {\n        A.add(i * i - i + 1);\n    }\n    int count = 0;\n    for (int i = 0; i < A.size(); i++) {\n        for (int j = i + 1; j < A.size(); j++) {\n            for (int k = j + 1; k < A.size(); k++) {\n                if ((A.get(i) + A.get(j) + A.get(k)) % 3 == 0) {\n                    count += 1;\n                }\n            }\n        }\n    }\n    return count;\n}", "pred": "func getMaxTriples(n: Int64): Int64 {\n    let A = ArrayList<Int64>()\n    for (i in 1..=n) {\n        A.append(i * i - i + 1)\n    }\n    var count = 0\n    for (i in 0..A.size) {\n        for (j in (i + 1)..A.size) {\n            for (k in (j + 1)..A.size) {\n                if ((A[i] + A[j] + A[k]) % 3 == 0) {\n                    count += 1\n                }\n            }\n        }\n    }\n    return count\n}\n"}
{"src": "/**\n * Returns a list of planets whose orbits are located between the orbits of two given planets.\n * The list is sorted by proximity to the sun.\n * Returns an empty list if either of the given planet names is incorrect.\n * \n * @param planet1 The name of the first planet.\n * @param planet2 The name of the second planet.\n * @return A list containing planets located between the orbits of planet1 and planet2, sorted by proximity to the sun.\n */\n\npublic List<String> bf(String planet1, String planet2) {\n    List<String> planet_names = Arrays.asList(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n    if (!planet_names.contains(planet1) || !planet_names.contains(planet2) || planet1.equals(planet2)) {\n        return List.of();\n    }\n    int planet1_index = planet_names.indexOf(planet1);\n    int planet2_index = planet_names.indexOf(planet2);\n    if (planet1_index < planet2_index) {\n        return planet_names.subList(planet1_index + 1, planet2_index);\n    } else {\n        return planet_names.subList(planet2_index + 1, planet1_index);\n    }\n}", "pred": "public func bf(planet1: String, planet2: String): ArrayList<String> {\n    let planet_names = ArrayList<String>([\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"])\n    if (!planet_names.contains(planet1) ||!planet_names.contains(planet2) || planet1 == planet2) {\n        return ArrayList<String>()\n    }\n    let planet1_index = planet_names.indexOf(planet1).getOrThrow()\n    let planet2_index = planet_names.indexOf(planet2).getOrThrow()\n    if (planet1_index < planet2_index) {\n        return ArrayList<String>(planet_names[planet1_index + 1..planet2_index])\n    } else {\n        return ArrayList<String>(planet_names[planet2_index + 1..planet1_index])\n    }\n}\n"}
{"src": "/**\n * Deletes strings with odd lengths from the input list, sorts the remaining strings\n * first by ascending length and then alphabetically for strings with the same length,\n * and returns the sorted list of strings.\n * \n * @param lst The list of strings to be processed.\n * @return The sorted list of strings after removing strings with odd lengths.\n */\n\npublic List<String> listSort(List<String> lst) {\n    List<String> lst_sorted = new ArrayList<>(lst);\n    Collections.sort(lst_sorted);\n    List<String> new_lst = new ArrayList<>();\n    for (String i : lst_sorted) {\n        if (i.length() % 2 == 0) {\n            new_lst.add(i);\n        }\n    }\n    new_lst.sort(Comparator.comparingInt(String::length));\n    return new_lst;\n}", "pred": "public func listSort(lst: ArrayList<String>): ArrayList<String> {\n    var lst_sorted: ArrayList<String> = ArrayList<String>(lst)\n    lst_sorted.sortBy({ s: String => s.size })\n    var new_lst: ArrayList<String> = ArrayList<String>()\n    for (i in lst_sorted) {\n        if (i.size % 2 == 0) {\n            new_lst.append(i)\n        }\n    }\n    new_lst.sortBy({ s: String => s.size })\n    return new_lst\n}\n"}
{"src": "/**\n * Returns the value of x if n is a prime number, otherwise returns the value of y.\n * \n * @param n The number to check if it's prime.\n * @param x The value to return if n is prime.\n * @param y The value to return if n is not prime.\n * @return The value of x if n is prime; otherwise, the value of y.\n */\n\npublic int xOrY(int n, int x, int y) {\n    if (n == 1) {\n        return y;\n    }\n    for (int i = 2; i < n; i++) {\n        if (n % i == 0) {\n            return y;\n        }\n    }\n    return x;\n}", "pred": "public func xOrY(n: Int64, x: Int64, y: Int64): Int64 {\n    if (n == 1) {\n        return y\n    }\n    for (i in 2..n) {\n        if (n % i == 0) {\n            return y\n        }\n    }\n    return x\n}\n"}
{"src": "/**\n * Computes the sum of squares of the numbers in the list that are odd integers.\n * Ignores numbers that are negative or not integers.\n * \n * @param lst The list of numbers (integers or doubles) to be processed.\n * @return The sum of squares of the odd integers in the list.\n *         Returns 0 if the input list is empty or contains no valid odd integers.\n */\n\npublic int doubleTheDifference(List<Object> lst) {\n    return lst.stream().filter(i -> i instanceof Integer p && p > 0 && p % 2 != 0).map(i -> (Integer) i * (Integer) i).reduce(Integer::sum).orElse(0);\n}", "pred": "public func doubleTheDifference(lst: ArrayList<Any>): Int64 {\n    return lst.stream().filter({\n        case Some(v: Int64) => v > 0 && v % 2!= 0\n        case _ => false\n    }).map({\n        case Some(v: Int64) => v * v\n        case _ => 0\n    }).reduce({\n        case Some(a: Int64) => a\n        case None => 0\n    })\n}\n"}
{"src": "/**\n * Compares the guesses against the actual scores for a series of matches and returns\n * a list of how far off each guess was from the corresponding score.\n * \n * @param game The list of actual scores for each match.\n * @param guess The list of guessed scores for each match.\n * @return A list of the absolute differences between the guesses and the actual scores.\n *         A value of 0 indicates a correct guess.\n */\n\npublic List<Integer> compare(List<Integer> game, List<Integer> guess) {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 0; i < game.size(); i++) {\n        result.add(Math.abs(game.get(i) - guess.get(i)));\n    }\n    return result;\n}", "pred": "public func compare(game: ArrayList<Int64>, guess: ArrayList<Int64>): ArrayList<Int64> {\n    var result = ArrayList<Int64>()\n    for (i in 0..game.size) {\n        result.append(math.abs(game[i] - guess[i]))\n    }\n    return result\n}\n"}
{"src": "/**\n * Finds the strongest extension from a list of extensions based on their strength,\n * where the strength is given by the fraction (number of uppercase letters - number of lowercase letters).\n * Returns a string in the format ClassName.StrongestExtensionName.\n * If there are ties in strength, chooses the extension that appears first in the list.\n * \n * @param class_name The name of the class as a string.\n * @param extensions The list of extensions to evaluate.\n * @return A string in the format ClassName.StrongestExtensionName representing the strongest extension.\n */\n\npublic String StrongestExtension(String class_name, List<String> extensions) {\n    String strong = extensions.get(0);\n    int my_val = (int) (strong.chars().filter(Character::isUpperCase).count() - strong.chars().filter(Character::isLowerCase).count());\n    for (String s : extensions) {\n        int val = (int) (s.chars().filter(Character::isUpperCase).count() - s.chars().filter(Character::isLowerCase).count());\n        if (val > my_val) {\n            strong = s;\n            my_val = val;\n        }\n    }\n    return class_name + \".\" + strong;\n}", "pred": "public func StrongestExtension(class_name: String, extensions: ArrayList<String>): String {\n    var strong: String = extensions.get(0).getOrThrow()\n    var my_val: Int64 = (strong.toRuneArray().filter({ c => c >= 'A' && c <= 'Z' }).size - strong.toRuneArray().filter({ c => c >= 'a' && c <= 'z' }).size)\n    for (s in extensions) {\n        var val: Int64 = (s.toRuneArray().filter({ c => c >= 'A' && c <= 'Z' }).size - s.toRuneArray().filter({ c => c >= 'a' && c <= 'z' }).size)\n        if (val > my_val) {\n            strong = s\n            my_val = val\n        }\n    }\n    return class_name + \".\" + strong\n}\n"}
{"src": "/**\n * Checks if the second word or any of its rotations is a substring in the first word.\n * \n * @param a The first word.\n * @param b The second word.\n * @return true if the second word or any of its rotations is a substring of the first word; otherwise, false.\n */\n\npublic boolean cycpatternCheck(String a, String b) {\n    int l = b.length();\n    String pat = b + b;\n    for (int i = 0; i <= a.length() - l; i++) {\n        for (int j = 0; j <= l; j++) {\n            if (a.substring(i, i + l).equals(pat.substring(j, j + l))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "pred": "public func cycpatternCheck(a: String, b: String): Bool {\n    let l = b.size\n    let pat = b + b\n    for (i in 0..a.size - l + 1) {\n        for (j in 0..l + 1) {\n            if (a[i..i + l] == pat[j..j + l]) {\n                return true\n            }\n        }\n    }\n    return false\n}\n"}
{"src": "/**\n * Counts the number of even and odd digits in the given integer.\n * \n * @param num The input integer.\n * @return A list containing the count of even digits (at index 0) and odd digits (at index 1).\n */\n\npublic List<Integer> evenOddCount(int num) {\n    int even_count = 0, odd_count = 0;\n    for (char i : String.valueOf(Math.abs(num)).toCharArray()) {\n        if ((i - '0') % 2 == 0) {\n            even_count += 1;\n        } else {\n            odd_count += 1;\n        }\n    }\n    return Arrays.asList(even_count, odd_count);\n}", "pred": "public func evenOddCount(num: Int64): ArrayList<Int64> {\n    var even_count: Int64 = 0\n    var odd_count: Int64 = 0\n    for (i in (num.toString()).toRuneArray()) {\n        if ((Int64(UInt32(i)) - Int64('0')) % 2 == 0) {\n            even_count += 1\n        } else {\n            odd_count += 1\n        }\n    }\n    return ArrayList<Int64>([even_count, odd_count])\n}\n"}
{"src": "/**\n * Converts a positive integer to its Roman numeral equivalent as a lowercase string.\n * \n * @param number The positive integer to convert (1 <= num <= 1000).\n * @return The Roman numeral representation of the input number in lowercase.\n */\n\npublic String intToMiniRoman(int number) {\n    List<Integer> num = Arrays.asList(1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000);\n    List<String> sym = Arrays.asList(\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\");\n    int i = 12;\n    String res = \"\";\n    while (number > 0) {\n        int div = number / num.get(i);\n        number %= num.get(i);\n        while (div != 0) {\n            res += sym.get(i);\n            div -= 1;\n        }\n        i -= 1;\n    }\n    return res.toLowerCase();\n}", "pred": "public func intToMiniRoman(number: Int64): String {\n    let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n    let sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"]\n    var i = 12\n    var res = \"\"\n    while (number > 0) {\n        let div = number / num[i]\n        number %= num[i]\n        while (div!= 0) {\n            res += sym[i]\n            div -= 1\n        }\n        i -= 1\n    }\n    return res.toAsciiLower()\n}\n"}
{"src": "/**\n * Determines if the three sides of a triangle form a right-angled triangle.\n * \n * @param a The length of side a.\n * @param b The length of side b.\n * @param c The length of side c.\n * @return true if the three sides form a right-angled triangle; otherwise, false.\n */\n\npublic boolean rightAngleTriangle(int a, int b, int c) {\n    return a * a == b * b + c * c || b * b == a * a + c * c || c * c == a * a + b * b;\n}", "pred": "func rightAngleTriangle(a: Int64, b: Int64, c: Int64): Bool {\n    return a * a == b * b + c * c || b * b == a * a + c * c || c * c == a * a + b * b\n}\n"}
{"src": "/**\n * Finds the word with the maximum number of unique characters from a list of strings.\n * If multiple strings have the maximum number of unique characters, returns the one that comes first lexicographically.\n * \n * @param words The list of strings to evaluate.\n * @return The word with the maximum number of unique characters.\n */\n\npublic int compare(String o1, String o2) {\n    Set<Character> s1 = new HashSet<>();\n    for (char ch : o1.toCharArray()) {\n        s1.add(ch);\n    }\n    Set<Character> s2 = new HashSet<>();\n    for (char ch : o2.toCharArray()) {\n        s2.add(ch);\n    }\n    if (s1.size() > s2.size()) {\n        return 1;\n    } else if (s1.size() < s2.size()) {\n        return -1;\n    } else {\n        return -o1.compareTo(o2);\n    }\n}\n});\nreturn words_sort.get(words_sort.size() - 1);\n}", "pred": "public func findMaxUniqueChars(words: ArrayList<String>): String {\n    var words_sort: ArrayList<String> = ArrayList<String>(words)\n    words_sort.sortBy({ o1: String, o2: String =>\n        if (o1.size > o2.size) {\n            return Ordering.GT\n        } else if (o1.size < o2.size) {\n            return Ordering.LT\n        } else {\n            return o1.compare(o2)\n        }\n    })\n    return words_sort.get(words_sort.size - 1).getOrThrow()\n}\n"}
{"src": "/**\n * Simulates a rabbit eating carrots to complete its daily meals.\n * \n * @param number The number of carrots already eaten.\n * @param need The number of additional carrots needed to complete the meals.\n * @param remaining The number of remaining carrots in stock.\n * @return An array containing:\n *         - The total number of carrots eaten after the meals.\n *         - The number of carrots left after the meals (if any).\n */\n\npublic List<Integer> eat(int number, int need, int remaining) {\n    if (need <= remaining) {\n        return Arrays.asList(number + need, remaining - need);\n    } else {\n        return Arrays.asList(number + remaining, 0);\n    }\n}", "pred": "public func eat(number: Int64, need: Int64, remaining: Int64): ArrayList<Int64> {\n    if (need <= remaining) {\n        return ArrayList<Int64>([number + need, remaining - need])\n    } else {\n        return ArrayList<Int64>([number + remaining, 0])\n    }\n}\n"}
{"src": "/**\n * Builds and evaluates an algebraic expression using the provided list of operators and operands.\n * The operators are applied sequentially between the operands to form the expression.\n * \n * @param operator The list of basic algebra operations (e.g., \"+\", \"*\", \"-\", \"/\", \"**\").\n * @param operand The list of integers used in the algebraic expression.\n * @return The result of evaluating the algebraic expression.\n */\n\npublic int doAlgebra(List<String> operator, List<Integer> operand) {\n    List<String> ops = new ArrayList<>(operator);\n    List<Integer> nums = new ArrayList<>(operand);\n    for (int i = ops.size() - 1; i >= 0; i--) {\n        if (ops.get(i).equals(\"**\")) {\n            nums.set(i, (int) Math.round(Math.pow(nums.get(i), nums.get(i + 1))));\n            nums.remove(i + 1);\n            ops.remove(i);\n        }\n    }\n    for (int i = 0; i < ops.size(); i++) {\n        if (ops.get(i).equals(\"*\")) {\n            nums.set(i, nums.get(i) * nums.get(i + 1));\n            nums.remove(i + 1);\n            ops.remove(i);\n            i--;\n        } else if (ops.get(i).equals(\"/\")) {\n            nums.set(i, nums.get(i) / nums.get(i + 1));\n            nums.remove(i + 1);\n            ops.remove(i);\n            i--;\n        }\n    }\n    for (int i = 0; i < ops.size(); i++) {\n        if (ops.get(i).equals(\"+\")) {\n            nums.set(i, nums.get(i) + nums.get(i + 1));\n            nums.remove(i + 1);\n            ops.remove(i);\n            i--;\n        } else if (ops.get(i).equals(\"-\")) {\n            nums.set(i, nums.get(i) - nums.get(i + 1));\n            nums.remove(i + 1);\n            ops.remove(i);\n            i--;\n        }\n    }\n    return nums.get(0);\n}", "pred": "public func doAlgebra(operator: ArrayList<String>, operand: ArrayList<Int64>): Int64 {\n    var ops = operator\n    var nums = operand\n    for (i in (ops.size - 1)..=0 : -1) {\n        if (ops[i] == \"**\") {\n            nums[i] = Int64(math.round(math.pow(Float64(nums[i]), Float64(nums[i + 1]))))\n            nums.remove(i + 1)\n            ops.remove(i)\n        }\n    }\n    for (i in 0..ops.size) {\n        if (ops[i] == \"*\") {\n            nums[i] = nums[i] * nums[i + 1]\n            nums.remove(i + 1)\n            ops.remove(i)\n            i--\n        } else if (ops[i] == \"/\") {\n            nums[i] = nums[i] / nums[i + 1]\n            nums.remove(i + 1)\n            ops.remove(i)\n            i--\n        }\n    }\n    for (i in 0..ops.size) {\n        if (ops[i] == \"+\") {\n            nums[i] = nums[i] + nums[i + 1]\n            nums.remove(i + 1)\n            ops.remove(i)\n            i--\n        } else if (ops[i] == \"-\") {\n            nums[i] = nums[i] - nums[i + 1]\n            nums.remove(i + 1)\n            ops.remove(i)\n            i--\n        }\n    }\n    return nums[0]\n}\n"}
{"src": "/**\n * Modifies the string based on the following rules:\n * - If a character is a letter, reverse its case (lowercase to uppercase or vice versa).\n * - If the string contains no letters, reverse the entire string.\n * \n * @param s The input string to be processed.\n * @return The modified string based on the specified rules.\n */\n\npublic String solve(String s) {\n    boolean flag = true;\n    StringBuilder new_string = new StringBuilder();\n    for (char i : s.toCharArray()) {\n        if (Character.isUpperCase(i)) {\n            new_string.append(Character.toLowerCase(i));\n            flag = false;\n        } else if (Character.isLowerCase(i)) {\n            new_string.append(Character.toUpperCase(i));\n            flag = false;\n        } else {\n            new_string.append(i);\n        }\n    }\n    if (flag) {\n        new_string.reverse();\n    }\n    return new_string.toString();\n}", "pred": "func solve(s: String): String {\n    var flag: Bool = true\n    var new_string: StringBuilder = StringBuilder()\n    for (i in s.toRuneArray()) {\n        if (UInt32(i) >= UInt32('A') && UInt32(i) <= UInt32('Z')) {\n            new_string.append(Char(UInt32(i) + 32))\n            flag = false\n        } else if (UInt32(i) >= UInt32('a') && UInt32(i) <= UInt32('z')) {\n            new_string.append(Char(UInt32(i) - 32))\n            flag = false\n        } else {\n            new_string.append(i)\n        }\n    }\n    if (flag) {\n        new_string.reverse()\n    }\n    return new_string.toString()\n}\n"}
{"src": "/**\n * Computes the MD5 hash of the input string \"text\".\n * If the input string is empty, returns Optional.empty().\n * \n * @param text The input string to compute the MD5 hash for.\n * @return An optional containing the MD5 hash string (length 32) of the input string,\n *         or Optional.empty() if the input string is empty.\n */\n\npublic Optional<String> stringToMd5(String text) throws NoSuchAlgorithmException {\n    if (text.isEmpty()) {\n        return Optional.empty();\n    }\n\n    String md5 = new BigInteger(1, java.security.MessageDigest.getInstance(\"MD5\").digest(text.getBytes())).toString(16);\n    md5 = \"0\".repeat(32 - md5.length()) + md5;\n    return Optional.of(md5);\n}", "pred": "public func stringToMd5(text: String): Option<String> {\n    if (text.isEmpty()) {\n        return Option<String>.None\n    }\n\n    let md5: String = md5Digest(text)\n    return Option<String>.Some(md5)\n}"}
{"src": "/**\n * Generates a list of even digits between two positive integers a and b, inclusive,\n * and returns them in ascending order.\n * \n * @param a The first positive integer.\n * @param b The second positive integer.\n * @return A list of even digits between a and b, sorted in ascending order.\n */\n\npublic List<Integer> generateIntegers(int a, int b) {\n    int lower = Math.max(2, Math.min(a, b));\n    int upper = Math.min(8, Math.max(a, b));\n\n    List<Integer> result = new ArrayList<>();\n    for (int i = lower; i <= upper; i += 2) {\n        result.add(i);\n    }\n    return result;\n}", "pred": "public func generateIntegers(a: Int64, b: Int64): ArrayList<Int64> {\n    let lower = math.max(2, math.min(a, b))\n    let upper = math.min(8, math.max(a, b))\n\n    let result = ArrayList<Int64>()\n    for (i in lower..=upper : 2) {\n        result.append(i)\n    }\n    return result\n}\n"}
